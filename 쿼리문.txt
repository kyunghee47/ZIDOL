SELECT * FROM user;
delete from user;

insert into user(user_email, user_name, user_nickname, user_password) values("wlsgh@gmail.com", "김진호", "지노", 1234);
insert into user(user_email, user_name, user_nickname, user_password) values("pipi@naver.com", "피", "피피", 0000);
insert into admin(user_code) value(1);
insert into admin(user_code) value(2);

SELECT * FROM cs;
delete from cs;

insert into cs(cs_type, cs_name) values("알고리즘", "거품 정렬(Bubble Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "선택 정렬(Selection Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "삽입 정렬(Insertion Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "퀵 정렬(Quick Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "병합 정렬(Merge Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "힙 정렬(Heap Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "기수 정렬(Radix Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "계수 정렬(Count Sort)");
insert into cs(cs_type, cs_name) values("알고리즘", "이분 탐색(Binary Search)");
insert into cs(cs_type, cs_name) values("알고리즘", "해시 테이블 구현");
insert into cs(cs_type, cs_name) values("알고리즘", "DFS & BFS");
insert into cs(cs_type, cs_name) values("알고리즘", "최장 증가 수열(LIS)");
insert into cs(cs_type, cs_name) values("알고리즘", "최소 공통 조상(LCA)");
insert into cs(cs_type, cs_name) values("알고리즘", "동적 계획법(Dynamic Programming)");
insert into cs(cs_type, cs_name) values("알고리즘", "다익스트라(Dijkstra) 알고리즘");
insert into cs(cs_type, cs_name) values("알고리즘", "비트마스크(BitMask)");

insert into cs(cs_type, cs_name) values("자료구조", "Array");
insert into cs(cs_type, cs_name) values("자료구조", "Array & ArrayList & LinkedList");
insert into cs(cs_type, cs_name) values("자료구조", "스택(Stack) & 큐(Queue)");
insert into cs(cs_type, cs_name) values("자료구조", "힙(Heap)");
insert into cs(cs_type, cs_name) values("자료구조", "트리(Tree)");
insert into cs(cs_type, cs_name) values("자료구조", "이진탐색트리(Binary Search Tree)");
insert into cs(cs_type, cs_name) values("자료구조", "해시(Hash)");
insert into cs(cs_type, cs_name) values("자료구조", "트라이(Trie)");
insert into cs(cs_type, cs_name) values("자료구조", "B-Tree & B+Tree");

insert into cs(cs_type, cs_name) values("컴퓨터구조", "컴퓨터 구조 기초");
insert into cs(cs_type, cs_name) values("컴퓨터구조", "컴퓨터의 구성");
insert into cs(cs_type, cs_name) values("컴퓨터구조", "중앙처리장치(CPU) 작동 원리");
insert into cs(cs_type, cs_name) values("컴퓨터구조", "고정 소수점 & 부동 소수점");
insert into cs(cs_type, cs_name) values("컴퓨터구조", "패리티 비트 & 해밍 코드");
insert into cs(cs_type, cs_name) values("컴퓨터구조", "ARM 프로세서");

insert into cs(cs_type, cs_name) values("데이터베이스", "키(Key) 정리");
insert into cs(cs_type, cs_name) values("데이터베이스", "SQL - JOIN");
insert into cs(cs_type, cs_name) values("데이터베이스", "SQL Injection");
insert into cs(cs_type, cs_name) values("데이터베이스", "SQL vs NoSQL");
insert into cs(cs_type, cs_name) values("데이터베이스", "정규화(Nomalization)");
insert into cs(cs_type, cs_name) values("데이터베이스", "이상(Anomaly)");
insert into cs(cs_type, cs_name) values("데이터베이스", "인덱스(INDEX)");
insert into cs(cs_type, cs_name) values("데이터베이스", "트랜잭션(Transaction)");
insert into cs(cs_type, cs_name) values("데이터베이스", "트랜잭션 격리 수준(Transaction Isolation Level)");
insert into cs(cs_type, cs_name) values("데이터베이스", "저장 프로시저(Stored PROCEDURE)");
insert into cs(cs_type, cs_name) values("데이터베이스", "레디스(Redis)");

insert into cs(cs_type, cs_name) values("네트워크", "OSI 7 계층");
insert into cs(cs_type, cs_name) values("네트워크", "TCP 3 way handshake & 4 way handshake");
insert into cs(cs_type, cs_name) values("네트워크", "TCP/IP 흐름제어 & 혼잡제어");
insert into cs(cs_type, cs_name) values("네트워크", "UDP");
insert into cs(cs_type, cs_name) values("네트워크", "대칭키 & 공개키");
insert into cs(cs_type, cs_name) values("네트워크", "HTTP & HTTPS");
insert into cs(cs_type, cs_name) values("네트워크", "TLS/SSL handshake");
insert into cs(cs_type, cs_name) values("네트워크", "로드 밸런싱(Load Balancing)");
insert into cs(cs_type, cs_name) values("네트워크", "Blocking,Non-blocking & Synchronous,Asynchronous");
insert into cs(cs_type, cs_name) values("네트워크", "Blocking & Non-Blocking I/O");

insert into cs(cs_type, cs_name) values("운영체제", "운영체제란");
insert into cs(cs_type, cs_name) values("운영체제", "프로세스 vs 스레드");
insert into cs(cs_type, cs_name) values("운영체제", "프로세스 주소 공간");
insert into cs(cs_type, cs_name) values("운영체제", "인터럽트(Interrupt)");
insert into cs(cs_type, cs_name) values("운영체제", "시스템 콜(System Call)");
insert into cs(cs_type, cs_name) values("운영체제", "PCB와 Context Switching");
insert into cs(cs_type, cs_name) values("운영체제", "IPC(Inter Process Communication)");
insert into cs(cs_type, cs_name) values("운영체제", "CPU 스케줄링");
insert into cs(cs_type, cs_name) values("운영체제", "데드락(DeadLock)");
insert into cs(cs_type, cs_name) values("운영체제", "Race Condition");
insert into cs(cs_type, cs_name) values("운영체제", "세마포어(Semaphore) & 뮤텍스(Mutex)");
insert into cs(cs_type, cs_name) values("운영체제", "페이징 & 세그먼테이션 (PDF)");
insert into cs(cs_type, cs_name) values("운영체제", "페이지 교체 알고리즘");
insert into cs(cs_type, cs_name) values("운영체제", "메모리(Memory)");
insert into cs(cs_type, cs_name) values("운영체제", "파일 시스템");

insert into cs(cs_type, cs_name) values("디자인패턴", "디자인패턴 개요(Overview)");
insert into cs(cs_type, cs_name) values("디자인패턴", "어댑터 패턴");
insert into cs(cs_type, cs_name) values("디자인패턴", "싱글톤 패턴");
insert into cs(cs_type, cs_name) values("디자인패턴", "탬플릿 메소드 패턴");
insert into cs(cs_type, cs_name) values("디자인패턴", "팩토리 메소드 패턴");
insert into cs(cs_type, cs_name) values("디자인패턴", "옵저버 패턴");
insert into cs(cs_type, cs_name) values("디자인패턴", "스트레티지 패턴");
insert into cs(cs_type, cs_name) values("디자인패턴", "컴포지트 패턴");
insert into cs(cs_type, cs_name) values("디자인패턴", "SOLID");

SELECT * FROM achievement;
delete from achievement;

insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-01", 1, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-02", 2, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-03", 3, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-04", 4, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-05", 5, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-06", 6, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-07", 7, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-01", 17, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-02", 18, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-03", 19, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-04", 20, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-05", 21, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-01", 26, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-02", 27, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-03", 28, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-01", 32, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-02", 33, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-03", 34, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-04", 35, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-05", 36, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-06", 37, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-07", 38, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-01", 43, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-02", 44, 1); 
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-01", 53, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-02", 54, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-03", 55, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-01", 68, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-02", 69, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-03", 70, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-04", 71, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-05", 72, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-06", 73, 1);
insert into achievement(achievement_reg_date, cs_code, user_code) values("2022-06-07", 74, 1);

SELECT * FROM board;
delete from board;

insert into board(board_title, board_content, board_type, board_reg_date, user_code) values("[SQL과 NOSQL의 차이] NoSQL 스키마 관련", "NoSQL에서 스키마가 없다고 하셨는데 최근 MongDB 컨퍼런스에서 'NoSQL에서 스키마가 없다는 말은 잘못된 말이다! 스키마를 RDBMS에 비해 덜 신경써도 될 뿐 중요하다' 라는 이야기를 들었습니다. 맞는내용인가요??", "질문게시판", curdate(), 1);
insert into board(board_title, board_content, board_type, board_reg_date, user_code) values("퀵 정렬(Quick Sort)에 관해", "퀵 정렬이 최악의 시간복잡도를 가지는 경우는 언제인가요??", "질문게시판", curdate(), 2);
insert into board(board_title, board_content, board_type, board_reg_date, user_code) values("React state관련 질문입니다.", "state를 직접 변경하지 않고 setState() 사용하는 이유가 무엇인가요?", "질문게시판", curdate(), 1);
insert into board(board_title, board_content, board_type, board_reg_date, user_code) values("브라우저 주소창에 google을 검색하면 어떤일이 일어나는지?", "정리해줄사람 있나요??", "질문게시판", curdate(), 1);
insert into board(board_title, board_content, board_type, board_reg_date, user_code) values("싱글톤 패턴의 단점", "단점에 관해 알고싶어요", "질문게시판", curdate(), 2);

SELECT * FROM reply;
delete from reply;

insert into reply(reply_content, board_code, user_code, reply_regdate) values("데이터가 역순이거나  완전히 정렬", 2, 1, curdate());
insert into reply(reply_content, board_code, user_code, reply_regdate) values("state는 immutable하게 관리해야한다. state객체를 직접 수정하게되면 컴포넌트가 변경된 것을 알지 못하기 때문에 변경된 부분이 있더라도 다시 리렌더링하지 않습니다.", 3, 2, curdate());
insert into reply(reply_content, board_code, user_code, reply_regdate) values("대기열, 캐싱, DNS, 라우팅(ip주소를 찾아가는 과정), ARP(실제물리적인 주소에 도달), 초기연결을 거쳐 컨텐츠를 다운받게 되고 이 후 브라우저 렌더링 과정을 거쳐 네이버라는 화면이 나온다. 또한 이러한 과정이 캡슐화, 비캡슐화 과정을 거쳐서 이루어집니다.", 4, 2, curdate());
insert into reply(reply_content, board_code, user_code, reply_regdate) values("싱글톤패턴은 TDD(Test Driven Development)를 할 때 걸림돌이 됩니다. TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 합니다. 하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기가 어렵습니다.", 5, 1, curdate());


SELECT * FROM cscontent;
delete from cscontent;

insert into cscontent (cs_content, cs_regdate, cs_code) values('# 거품 정렬 (Bubble Sort)\n\n*Assembled by GimunLee (2019-10-29)*\n\n<br>\n\n## Goal\n\n- Bubble Sort에 대해 설명할 수 있다.\n- Bubble Sort 과정에 대해 설명할 수 있다.\n- Bubble Sort을 구현할 수 있다.\n- Bubble Sort의 시간복잡도와 공간복잡도를 계산할 수 있다.\n\n<br>\n\n## Abstract\n\nBubble Sort는 Selection Sort와 유사한 알고리즘으로 **```서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘```** 입니다.\n\n이름의 유래로는 정렬 과정에서 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어졌다고 합니다.\n\n<br>\n\n## Process (Ascending)\n\n1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로  (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환합니다.\n2. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외됩니다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어납니다.\n\n<br>\n\n## Java Code (Ascending)\n\n```java\nvoid bubbleSort(int[] arr) {\n    int temp = 0;\n	for(int i = 0; i < arr.length; i++) {       // 1.\n		for(int j= 1 ; j < arr.length-i; j++) { // 2.\n			if(arr[j-1] > arr[j]) {             // 3.\n                // swap(arr[j-1], arr[j])\n				temp = arr[j-1];\n				arr[j-1] = arr[j];\n				arr[j] = temp;\n			}\n		}\n	}\n	System.out.println(Arrays.toString(arr));\n}\n```\n\n1. 제외될 원소의 갯수를 의미합니다. 1회전이 끝난 후, 배열의 마지막 위치에는 가장 큰 원소가 위치하기 때문에 하나씩 증가시켜줍니다.\n2. 원소를 비교할 index를 뽑을 반복문입니다. j는 현재 원소를 가리키고, j-1은 이전 원소를 가리키게 되므로, j는 1부터 시작하게 됩니다.\n3. 현재 가르키고 있는 두 원소의 대소를 비교합니다. 해당 코드는 오름차순 정렬이므로 현재 원소보다 이전 원소가 더 크다면 이전 원소가 뒤로 가야하므로 서로 자리를 교환해줍니다.\n\n<br>\n\n## GIF로 이해하는 Bubble Sort\n\n<img src=\"https://user-images.githubusercontent.com/88614978/172395133-ea26feac-3dea-4133-9e38-5d0e36a75ff5.gif\">\n\n<br>\n\n## 시간복잡도\n\n시간복잡도를 계산하면, `(n-1) + (n-2) + (n-3) + .... + 2 + 1 => n(n-1)/2`이므로, **O(n^2)** 입니다.  또한, Bubble Sort는 정렬이 돼있던 안돼있던, 2개의 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 **O(n^2)** 으로 동일합니다. *(개선된 Bubble Sort가 존재하긴 하나, 이번 장은 기초를 다지기 위한 학습이므로 넘어가겠습니다.)*\n\n<br/>\n\n## 공간복잡도\n\n주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 **O(n)** 입니다.\n\n<br>\n\n## 장점\n\n- 구현이 매우 간단하고, 소스코드가 직관적입니다.\n- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않습니다. => 제자리 정렬(in-place sorting)\n- 안정 정렬(Stable Sort) 입니다.\n\n<br>\n\n## 단점\n\n- 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적입니다.\n- 정렬 돼있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 됩니다.\n\n<br>\n\n## Conclusion\n\n정렬 알고리즘 중에 가장 직관적인 Bubble Sort에 대해 알아보았습니다. 기술 면접에서도 종종 나오는 정렬 알고리즘으로 알아두시면 좋을 것 같습니다.\n\n<br>\n\n\n## Reference & Additional Resources\n\n- https://zeddios.tistory.com/20 \n- https://jinhyy.tistory.com/9 \n- https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html \n\n\n\n', '2022-06-07', '1');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 선택 정렬 (Selection Sort)\n\n*Assembled by GimunLee (2019-10-29)*\n\n<br>\n\n## Goal\n\n- Selection Sort에 대해 설명할 수 있다.\n- Selection Sort 과정에 대해 설명할 수 있다.\n- Selection Sort을 구현할 수 있다.\n- Selection Sort의 시간복잡도와 공간복잡도를 계산할 수 있다.\n\n<br>\n\n## Abstract\n\nSelection Sort는 Bubble Sort과 유사한 알고리즘으로, **해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘**입니다.\n\nSelection Sort와 Insertion Sort를 헷갈려하시는 분들이 종종 있는데, Selection Sort는 배열에서 **해당 자리를 선택하고 그 자리에 오는 값을 찾는 것**이라고 생각하시면 편합니다.\n\n<br>\n\n## Process (Ascending)\n\n1. 주어진 배열 중에 최소값을 찾습니다.\n2. 그 값을 맨 앞에 위치한 값과 교체합니다. (pass)\n3. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체합니다.\n\n<br>\n\n## Java Code (Ascending)\n\n```java\nvoid selectionSort(int[] arr) {\n    int indexMin, temp;\n    for (int i = 0; i < arr.length-1; i++) {        // 1.\n        indexMin = i;\n        for (int j = i + 1; j < arr.length; j++) {  // 2.\n            if (arr[j] < arr[indexMin]) {           // 3.\n                indexMin = j;\n            }\n        }\n        // 4. swap(arr[indexMin], arr[i])\n        temp = arr[indexMin];\n        arr[indexMin] = arr[i];\n        arr[i] = temp;\n  }\n  System.out.println(Arrays.toString(arr));\n}\n```\n\n1. 우선, 위치(index)를 **선택**해줍니다.\n2. i+1번째 원소부터 선택한 위치(index)의 값과 비교를 시작합니다.\n3. 오름차순이므로 현재 선택한 자리에 있는 값보다 순회하고 있는 값이 작다면, 위치(index)를 갱신해줍니다.\n4. \'2\'번 반복문이 끝난 뒤에는 indexMin에 \'1\'번에서 선택한 위치(index)에 들어가야하는 값의 위치(index)를 갖고 있으므로 서로 교환(swap)해줍니다.\n\n<br>\n\n## GIF로 이해하는 Selection Sort\n\n<img src=\"https://user-images.githubusercontent.com/88614978/172397211-6b384c2c-1969-4c78-b638-12d32cf5e9be.gif\">\n\n<br>\n\n## 시간복잡도\n\n데이터의 개수가 n개라고 했을 때, \n\n- 첫 번째 회전에서의 비교횟수 : 1 ~ (n-1) => n-1\n\n- 두 번째 회전에서의 비교횟수 : 2 ~ (n-1) => n-2\n\n  ...\n\n- ```(n-1) + (n-2) + .... + 2 + 1 => n(n-1)/2```\n\n비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 배열을 정렬하는데 O(n^2) 만큼의 시간이 걸립니다. 최선, 평균, 최악의 경우 시간복잡도는 **O(n^2)** 으로 동일합니다.\n\n<br/>\n\n## 공간복잡도\n\n주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 **O(n)** 입니다.\n\n<br>\n\n## 장점\n\n- Bubble sort와 마찬가지로 알고리즘이 단순합니다.\n- 정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적입니다.\n- Bubble Sort와 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않습니다. => 제자리 정렬(in-place sorting)\n\n<br>\n\n## 단점\n\n- 시간복잡도가 O(n^2)으로, 비효율적입니다.\n- **불안정 정렬(Unstable Sort)** 입니다.\n\n<br>\n\n## Conclusion\n\nBubble Sort와 유사하지만, 조금 더 빠른 Selection Sort에 대해 알아보았습니다. 기술 면접이나 시험(n번째 회전에 정렬 상태)에서도 종종 나오는 정렬이니 알아두시면 좋을 것 같습니다.\n\n<br>\n\n## Reference & Additional Resources\n\n- https://jinhyy.tistory.com/9 \n- [https://medium.com/@joongwon/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EC%B4%88-805391cb088e](https://medium.com/@joongwon/정렬-알고리즘-기초-805391cb088e) \n- https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html \n- [https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC](https://ko.wikipedia.org/wiki/선택_정렬) ', '2022-06-07', '2');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# 삽입 정렬 (Insertion Sort)\n\n*Assembled by GimunLee (2019-10-30)*\n\n<br>\n\n## Goal\n\n- Insertion Sort에 대해 설명할 수 있다.\n- Insertion Sort 과정에 대해 설명할 수 있다.\n- Insertion Sort을 구현할 수 있다.\n- Insertion Sort의 시간복잡도와 공간복잡도를 계산할 수 있다.\n- Insertion Sort와 Selection Sort 차이에 대해 설명할 수 있다.\n\n<br>\n\n## Abstract\n\n손 안의 카드를 정렬하는 방법과 유사합니다.\n\nInsertion Sort는 Selection Sort와 유사하지만, 좀 더 효율적인 정렬 알고리즘입니다.\n\nInsertion Sort는 **2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입** 하여 정렬하는 알고리즘입니다.\n\n최선의 경우 O(N)이라는 엄청나게 빠른 효율성을 가지고 있어, 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘입니다.\n\n<br>\n\n## Process (Ascending)\n\n1. 정렬은 2번째 위치(index)의 값을 temp에 저장합니다.\n2. temp와 이전에 있는 원소들과 비교하며 삽입해나갑니다.\n3. \'1\'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복합니다.\n\n<br>\n\n## Java Code (Ascending)\n\n```java\nvoid insertionSort(int[] arr)\n{\n   for(int index = 1 ; index < arr.length ; index++){ // 1.\n      int temp = arr[index];\n      int prev = index - 1;\n      while( (prev >= 0) && (arr[prev] > temp) ) {    // 2.\n         arr[prev+1] = arr[prev];\n         prev--;\n      }\n      arr[prev + 1] = temp;                           // 3.\n   }\n   System.out.println(Arrays.toString(arr));\n}\n```\n\n1. 첫 번째 원소 앞(왼쪽)에는 어떤 원소도 갖고 있지 않기 때문에, 두 번째 위치(index)부터 탐색을 시작합니다. temp에 임시로 해당 위치(index) 값을 저장하고, prev에는 해당 위치(index)의 이전 위치(index)를 저장합니다.\n2. 이전 위치(index)를 가리키는 prev가 음수가 되지 않고, 이전 위치(index)의 값이 \'1\'번에서 선택한 값보다 크다면, 서로 값을 교환해주고 prev를 더 이전 위치(index)를 가리키도록 합니다.\n3. \'2\'번에서 반복문이 끝나고 난 뒤, prev에는 현재 **temp 값보다 작은 값들 중 제일 큰 값의 위치(index)** 를 가리키게 됩니다. 따라서, (prev+1)에 temp 값을 삽입해줍니다.\n\n<br>\n\n## GIF로 이해하는 Insertion Sort\n\n<img src=\"https://user-images.githubusercontent.com/88614978/172395396-047c4d40-8a32-48bb-a6de-67b490f7e1c8.gif\">\n\n<br>\n\n## 시간복잡도\n\n최악의 경우(역으로 정렬되어 있을 경우) Selection Sort와 마찬가지로, ```(n-1) + (n-2) + .... + 2 + 1 => n(n-1)/2``` 즉, **O(n^2)** 입니다. \n\n하지만, 모두 정렬이 되어있는 경우(Optimal)한 경우, 한번씩 밖에 비교를 안하므로 **O(n)** 의 시간복잡도를 가지게 됩니다. 또한, 이미 정렬되어 있는 배열에 자료를 하나씩 삽입/제거하는 경우에는, 현실적으로 최고의 정렬 알고리즘이 되는데, 탐색을 제외한 오버헤드가 매우 적기 때문입니다. \n\n최선의 경우는 **O(n)** 의 시간복잡도를 갖고, 평균과 최악의 경우 **O(n^2)** 의 시간복잡도를 갖게 됩니다.\n\n<br/>\n\n## 공간복잡도\n\n주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 **O(n)** 입니다.\n\n<br>\n\n## 장점\n\n- 알고리즘이 단순합니다.\n- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있습니다.\n- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않습니다. => 제자리 정렬(in-place sorting)\n- **안정 정렬(Stable Sort)** 입니다.\n- Selection Sort나 Bubble Sort과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠릅니다.\n\n<br>\n\n## 단점\n\n- 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적입니다.\n- Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적입니다.\n\n<br>\n\n## Conclusion\n\nSelection Sort와 Insertion Sort는 k번째 반복 이후, 첫번째 k 요소가 정렬된 순서로 온다는 점에서 유사합니다. 하지만, Selection Sort는 k+1번째 요소를 찾기 위해 나머지 모든 요소들을 탐색하지만 Insertion Sort는 k+1번째 요소를 배치하는 데 필요한 만큼의 요소만 탐색하기 때문에 훨씬 효율적으로 실행된다는 차이가 있습니다. \n\n<br>\n\n## Reference & Additional Resources\n\n- https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html \n- [https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC](https://ko.wikipedia.org/wiki/삽입_정렬) \n- https://jinhyy.tistory.com/9\n- https://zeddios.tistory.com/20#recentComments \n', '2022-06-07', '3');
insert into cscontent (cs_content, cs_regdate, cs_code) values('안전 정렬 : 동일한 값에 기존 순서가 유지 (버블, 삽입)\n\n불안정 정렬 : 동일한 값에 기존 순서가 유지X (선택,퀵)\n\n\n\n#### 퀵소트\n\n---\n\n퀵소트는 최악의 경우 O(n^2), 평균적으로 Θ(nlogn)을 가짐\n\n\n\n```java\npublic void quickSort(int[] array, int left, int right) {\n    \n    if(left >= right) return;\n    \n    int pi = partition(array, left, right);\n    \n    quickSort(array, left, pi-1);\n    quickSort(array, pi+1, right);\n    \n}\n```\n\n\n\n피벗 선택 방식 : 첫번째, 중간, 마지막, 랜덤\n\n(선택 방식에 따라 속도가 달라지므로 중요함)\n\n\n\n```java\npublic int partition(int[] array, int left, int right) {\n    int pivot = array[left];\n    int i = left, j = right;\n    \n    while(i < j) {\n        while(pivot < array[j]) {\n            j--;\n        }\n        while(i<j && pivot >= array[i]){\n            i++;\n        }\n        swap(array, i, j);\n    }\n    array[left] = array[i];\n    array[i] = pivot;\n    \n    return i;\n}\n```\n\n1. 피벗 선택\n2. 오른쪽(j)에서 왼쪽으로 가면서 피벗보다 작은 수 찾음\n3. 왼쪽(i)에서 오른쪽으로 가면서 피벗보다 큰 수 찾음\n4. 각 인덱스 i, j에 대한 요소를 교환\n5. 2,3,4번 과정 반복\n6. 더이상 2,3번 진행이 불가능하면, 현재 피벗과 교환\n7. 이제 교환된 피벗 기준으로 왼쪽엔 피벗보다 작은 값, 오른쪽엔 큰 값들만 존재함\n\n\n\n---\n\n\n\n버블정렬은 모든 배열의 요소에 대한 인덱스를 하나하나 증가하며 비교해나가는 O(n^2)\n\n퀵정렬의 경우 인접한 것이 아닌 서로 먼 거리에 있는 요소를 교환하면서 속도를 줄일 수 있음\n\nBut, **피벗 값이 최소나 최대값으로 지정되어 파티션이 나누어지지 않았을 때** O(n^2)에 대한 시간복잡도를 가짐\n\n\n\n#### 퀵소트 O(n^2) 해결 방법\n\n---\n\n이런 상황에서는 퀵소트 장점이 사라지므로, 피벗을 선택할 때 `중간 요소`로 선택하면 해결이 가능함\n\n\n\n```java\npublic int partition(int[] array, int left, int right) {\n    int mid = (left + right) / 2;\n    swap(array, left, mid);\n    ...\n}\n```\n\n이는 다른 O(nlogn) 시간복잡도를 가진 소트들보다 빠르다고 알려져있음\n\n> 먼거리 교환 처리 + 캐시 효율(한번 선택된 기준은 제외시킴)\n\n\n\n```java\nprivate void solve() {\n    int[] array = { 80, 70, 60, 50, 40, 30, 20 };\n    quicksort(array, 0, array.length - 1);\n \n    for (int v : array) {\n        System.out.println(v);\n    }\n}\n \npublic static int partition(int[] array, int left, int right) {\n    int mid = (left + right) / 2;\n    swap(array, left, mid);\n \n    int pivot = array[left];\n    int i = left, j = right;\n \n    while (i < j) {\n        while (pivot < array[j]) {\n            j--;\n        }\n \n        while (i < j && pivot >= array[i]) {\n            i++;\n        }\n        swap(array, i, j);\n    }\n    array[left] = array[i];\n    array[i] = pivot;\n    return i;\n}\n \npublic static void swap(int[] array, int a, int b) {\n    int temp = array[b];\n    array[b] = array[a];\n    array[a] = temp;\n}\n \npublic static void quicksort(int[] array, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n \n    int pi = partition(array, left, right);\n \n    quicksort(array, left, pi - 1);\n    quicksort(array, pi + 1, right);\n}\n\n```\n', '2022-06-07', '4');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### 머지 소트(Merge Sort)\n\n---\n\n\n\n합병 정렬이라고도 부르며, 분할 정복 방법을 통해 구현\n\n***분할 정복이란?***\n\n> 큰 문제를 작은 문제 단위로 쪼개면서 해결해나가는 방식\n\n\n\n빠른 정렬로 분류되며, 퀵소트와 함께 많이 언급되는 정렬 방식이다.\n\n\n\n퀵소트와는 반대로 `안정 정렬`에 속함\n\n**시간복잡도**\n\n|   평균   |   최선   |   최악   |\n| :------: | :------: | :------: |\n| Θ(nlogn) | Ω(nlogn) | O(nlogn) |\n\n요소를 쪼갠 후, 다시 합병시키면서 정렬해나가는 방식으로, 쪼개는 방식은 퀵정렬과 유사\n\n\n\n- mergeSort\n\n```java\npublic void mergeSort(int[] array, int left, int right) {\n    \n    if(left < right) {\n        int mid = (left + right) / 2;\n        \n        mergeSort(array, left, mid);\n        mergeSort(array, mid+1, right);\n        merge(array, left, mid, right);\n    }\n    \n}\n```\n\n정렬 로직에 있어서 merge() 메소드가 핵심\n\n\n\n*퀵소트와의 차이점*\n\n> 퀵정렬 : 우선 피벗을 통해 정렬(partition) → 영역을 쪼갬(quickSort)\n>\n> 합병정렬 : 영역을 쪼갤 수 있을 만큼 쪼갬(mergeSort) →  정렬(merge)\n\n\n\n- merge()\n\n```java\npublic static void merge(int[] array, int left, int mid, int right) {\n    int[] L = Arrays.copyOfRange(array, left, mid + 1);\n    int[] R = Arrays.copyOfRange(array, mid + 1, right + 1);\n    \n    int i = 0, j = 0, k = left;\n    int ll = L.length, rl = R.length;\n    \n    while(i < ll && j < rl) {\n        if(L[i] <= R[j]) {\n            array[k] = L[i++];\n        }\n        else {\n            array[k] = R[j++];\n        }\n        k++;\n    }\n    \n    // remain\n    while(i < ll) {\n        array[k++] = L[i++];\n    }\n    while(j < rl) {\n        array[k++] = R[j++];\n    }\n}\n```\n\n이미 **합병의 대상이 되는 두 영역이 각 영역에 대해서 정렬이 되어있기 때문**에 단순히 두 배열을 **순차적으로 비교하면서 정렬할 수가 있다.**\n\n\n\n\n\n**★★★합병정렬은 순차적**인 비교로 정렬을 진행하므로, **LinkedList의 정렬이 필요할 때 사용하면 효율적**이다.★★★\n\n\n\n*LinkedList를 퀵정렬을 사용해 정렬하면?*\n\n> 성능이 좋지 않음\n>\n> 퀵정렬은, 순차 접근이 아닌 **임의 접근이기 때문**\n\n\n\n**LinkedList는 삽입, 삭제 연산에서 유용**하지만 **접근 연산에서는 비효율적**임\n\n따라서 임의로 접근하는 퀵소트를 활용하면 오버헤드 발생이 증가하게 됨\n\n> 배열은 인덱스를 이용해서 접근이 가능하지만, LinkedList는 Head부터 탐색해야 함\n>\n> 배열[O(1)] vs LinkedList[O(n)] \n\n\n\n\n\n```java\nprivate void solve() {\n    int[] array = { 230, 10, 60, 550, 40, 220, 20 };\n \n    mergeSort(array, 0, array.length - 1);\n \n    for (int v : array) {\n        System.out.println(v);\n    }\n}\n \npublic static void mergeSort(int[] array, int left, int right) {\n    if (left < right) {\n        int mid = (left + right) / 2;\n \n        mergeSort(array, left, mid);\n        mergeSort(array, mid + 1, right);\n        merge(array, left, mid, right);\n    }\n}\n \npublic static void merge(int[] array, int left, int mid, int right) {\n    int[] L = Arrays.copyOfRange(array, left, mid + 1);\n    int[] R = Arrays.copyOfRange(array, mid + 1, right + 1);\n \n    int i = 0, j = 0, k = left;\n    int ll = L.length, rl = R.length;\n \n    while (i < ll && j < rl) {\n        if (L[i] <= R[j]) {\n            array[k] = L[i++];\n        } else {\n            array[k] = R[j++];\n        }\n        k++;\n    }\n \n    while (i < ll) {\n        array[k++] = L[i++];\n    }\n \n    while (j < rl) {\n        array[k++] = R[j++];\n    }\n}\n```\n', '2022-06-07', '5');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### 힙 소트(Heap Sort)\n\n---\n\n\n\n완전 이진 트리를 기본으로 하는 힙(Heap) 자료구조를 기반으로한 정렬 방식\n\n***완전 이진 트리란?***\n\n> 삽입할 때 왼쪽부터 차례대로 추가하는 이진 트리\n\n\n\n힙 소트는 `불안정 정렬`에 속함\n\n\n\n**시간복잡도**\n\n|   평균   |   최선   |   최악   |\n| :------: | :------: | :------: |\n| Θ(nlogn) | Ω(nlogn) | O(nlogn) |\n\n\n\n##### 과정\n\n1. 최대 힙을 구성\n2. 현재 힙 루트는 가장 큰 값이 존재함. 루트의 값을 마지막 요소와 바꾼 후, 힙의 사이즈 하나 줄임\n3. 힙의 사이즈가 1보다 크면 위 과정 반복\n\n\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/999896445AD4953023\">\n\n루트를 마지막 노드로 대체 (11 → 4), 다시 최대 힙 구성\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/99E1AD445AD4953015\">\n\n\n\n이와 같은 방식으로 최대 값을 하나씩 뽑아내면서 정렬하는 것이 힙 소트\n\n\n\n```java\npublic void heapSort(int[] array) {\n    int n = array.length;\n    \n    // max heap 초기화\n    for (int i = n/2-1; i>=0; i--){\n        heapify(array, n, i); // 1\n    }\n    \n    // extract 연산\n    for (int i = n-1; i>0; i--) {\n        swap(array, 0, i); \n        heapify(array, i, 0); // 2\n    }\n}\n```\n\n\n\n##### 1번째 heapify\n\n> 일반 배열을 힙으로 구성하는 역할\n>\n> 자식노드로부터 부모노드 비교\n>\n> \n>\n> - *n/2-1부터 0까지 인덱스가 도는 이유는?*\n>\n>   부모 노드의 인덱스를 기준으로 왼쪽 자식노드 (i*2 + 1), 오른쪽 자식 노드(i*2 + 2)이기 때문\n\n\n\n##### 2번째 heapify\n\n> 요소가 하나 제거된 이후에 다시 최대 힙을 구성하기 위함\n>\n> 루트를 기준으로 진행(extract 연산 처리를 위해)\n\n\n\n```java\npublic void heapify(int array[], int n, int i) {\n    int p = i;\n    int l = i*2 + 1;\n    int r = i*2 + 2;\n    \n    //왼쪽 자식노드\n    if (l < n && array[p] < array[l]) {\n        p = l;\n    }\n    //오른쪽 자식노드\n    if (r < n && array[p] < array[r]) {\n        p = r;\n    }\n    \n    //부모노드 < 자식노드\n    if(i != p) {\n        swap(array, p, i);\n        heapify(array, n, p);\n    }\n}\n```\n\n**다시 최대 힙을 구성할 때까지** 부모 노드와 자식 노드를 swap하며 재귀 진행\n\n\n\n퀵정렬과 합병정렬의 성능이 좋기 때문에 힙 정렬의 사용빈도가 높지는 않음.\n\n하지만 힙 자료구조가 많이 활용되고 있으며, 이때 함께 따라오는 개념이 `힙 소트`\n\n\n\n##### 힙 소트가 유용할 때\n\n- 가장 크거나 가장 작은 값을 구할 때\n\n  > 최소 힙 or 최대 힙의 루트 값이기 때문에 한번의 힙 구성을 통해 구하는 것이 가능\n\n- 최대 k 만큼 떨어진 요소들을 정렬할 때\n\n  > 삽입정렬보다 더욱 개선된 결과를 얻어낼 수 있음\n\n\n\n##### 전체 소스 코드\n\n```java\nprivate void solve() {\n    int[] array = { 230, 10, 60, 550, 40, 220, 20 };\n \n    heapSort(array);\n \n    for (int v : array) {\n        System.out.println(v);\n    }\n}\n \npublic static void heapify(int array[], int n, int i) {\n    int p = i;\n    int l = i * 2 + 1;\n    int r = i * 2 + 2;\n \n    if (l < n && array[p] < array[l]) {\n        p = l;\n    }\n \n    if (r < n && array[p] < array[r]) {\n        p = r;\n    }\n \n    if (i != p) {\n        swap(array, p, i);\n        heapify(array, n, p);\n    }\n}\n \npublic static void heapSort(int[] array) {\n    int n = array.length;\n \n    // init, max heap\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(array, n, i);\n    }\n \n    // for extract max element from heap\n    for (int i = n - 1; i > 0; i--) {\n        swap(array, 0, i);\n        heapify(array, i, 0);\n    }\n}\n \npublic static void swap(int[] array, int a, int b) {\n    int temp = array[a];\n    array[a] = array[b];\n    array[b] = temp;\n}\n```\n', '2022-06-07', '6');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### Comparison Sort\n\n---\n\n> N개 원소의 배열이 있을 때, 이를 모두 정렬하는 가짓수는 N!임\n>\n> 따라서, Comparison Sort를 통해 생기는 <u>트리의 말단 노드</u>가 N! 이상의 노드 갯수를 갖기 위해서는, 2^h >= N! 를 만족하는 h를 가져야 하고, 이 식을 h > O(nlgn)을 가져야 한다. (h는 트리의 높이,,, 즉 Comparison sort의 시간 복잡도임)\n\n이런 O(nlgn)을 줄일 수 있는 방법은 Comparison을 하지 않는 것\n\n\n\n#### Radix sort\n\n----\n\n데이터를 구성하는 기본 요소 (Radix) 를 이용하여 정렬을 진행하는 방식\n\n> 입력 데이터의 최대값에 따라서 Counting Sort의 비효율성을 개선하기 위해서, Radix Sort를 사용할 수 있음.\n>\n> 자릿수의 값 별로 (예) 둘째 자리, 첫째 자리) 정렬을 하므로, 나올 수 있는 값의 최대 사이즈는 9임 (범위 : 0 ~ 9)\n\n* 시간 복잡도 : O(d * (n + b))  \n\n  -> d는 정렬할 숫자의 자릿수, b는 10 (k와 같으나 10으로 고정되어 있다.)\n\n  ( Counting Sort의 경우 : O(n + k) 로 배열의 최댓값 k에 영향을 받음 )\n\n* 장점 : 문자열, 정수 정렬 가능\n\n* 단점 : 자릿수가 없는 것은 정렬할 수 없음. (부동 소숫점)\n\n  중간 결과를 저장할 bucket 공간이 필요함.\n\n#### 소스 코드\n\n```c\nvoid countSort(int arr[], int n, int exp) {\n	int buffer[n];\n    int i, count[10] = {0};\n    \n    // exp의 자릿수에 해당하는 count 증가\n    for (i = 0; i < n; i++){\n        count[(arr[i] / exp) % 10]++;\n    }\n    // 누적합 구하기\n    for (i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    // 일반적인 Counting sort 과정\n    for (i = n - 1; i >= 0; i--) {\n        buffer[count[(arr[i]/exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    for (i = 0; i < n; i++){\n        arr[i] = buffer[i];\n    }\n}\n\nvoid radixsort(int arr[], int n) {\n     // 최댓값 자리만큼 돌기\n    int m = getMax(arr, n);\n    \n    // 최댓값을 나눴을 때, 0이 나오면 모든 숫자가 exp의 아래\n    for (int exp = 1; m / exp > 0; exp *= 10) {\n        countSort(arr, n, exp);\n    }\n}\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);			// 좋은 습관\n    radixsort(arr, n);\n    \n    for (int i = 0; i < n; i++){\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n```\n\n\n\n#### 질문\n\n---\n\nQ1) 왜 낮은 자리수부터 정렬을 합니까?\n\nMSD (Most-Significant-Digit) 과 LSD (Least-Significant-Digit)을 비교하라는 질문\n\nMSD는 가장 큰 자리수부터 Counting sort 하는 것을 의미하고, LSD는 가장 낮은 자리수부터 Counting sort 하는 것을 의미함. (즉, 둘 다 할 수 있음)\n\n* LSD의 경우 1600000 과 1을 비교할 때, Digit의 갯수만큼 따져야하는 단점이 있음.\n  그에 반해 MSD는 마지막 자리수까지 확인해 볼 필요가 없음.\n* LSD는 중간에 정렬 결과를 알 수 없음. (예) 10004와 70002의 비교)\n  반면, MSD는 중간에 중요한 숫자를 알 수 있음. 따라서 시간을 줄일 수 있음. 그러나, 정렬이 되었는지 확인하는 과정이 필요하고, 이 때문에 메모리를 더 사용\n* LSD는 알고리즘이 일관됨 (Branch Free algorithm)\n  그러나 MSD는 일관되지 못함. --> 따라서 Radix sort는 주로 LSD를 언급함.\n* LSD는 자릿수가 정해진 경우 좀 더 빠를 수 있음.', '2022-06-07', '7');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### Comparison Sort\n\n------\n\n> N개 원소의 배열이 있을 때, 이를 모두 정렬하는 가짓수는 N!임\n>\n> 따라서, Comparison Sort를 통해 생기는 <u>트리의 말단 노드</u>가 N! 이상의 노드 갯수를 갖기 위해서는, 2^h >= N! 를 만족하는 h를 가져야 하고, 이 식을 h > O(nlgn)을 가져야 한다. (h는 트리의 높이,,, 즉 Comparison sort의 시간 복잡도임)\n\n이런 O(nlgn)을 줄일 수 있는 방법은 Comparison을 하지 않는 것\n\n\n\n#### Counting Sort 과정\n\n----\n\n시간 복잡도 : O(n + k) -> k는 배열에서 등장하는 최대값\n\n공간 복잡도 : O(k) -> k만큼의 배열을 만들어야 함.\n\nCounting이 필요 : 각 숫자가 몇 번 등장했는지 센다.\n\n```c\nint arr[5]; 		// [5, 4, 3, 2, 1]\nint sorted_arr[5];\n// 과정 1 - counting 배열의 사이즈를 최대값 5가 담기도록 크게 잡기\nint counting[6];	// 단점 : counting 배열의 사이즈의 범위를 가능한 값의 범위만큼 크게 잡아야 하므로, 비효율적이 됨.\n\n// 과정 2 - counting 배열의 값을 증가해주기.\nfor (int i = 0; i < arr.length; i++) {\n    counting[arr[i]]++;\n}\n// 과정 3 - counting 배열을 누적합으로 만들어주기.\nfor (int i = 1; i < arr.length; i++) {\n    counting[i] += counting[i - 1];\n}\n// 과정 4 - 뒤에서부터 배열을 돌면서, 해당하는 값의 인덱스에 값을 넣어주기.\nfor (int i = arr.length - 1; i >= 0; i--) {\n    sorted_arr[counting[arr[i]]] = arr[i];\n    counting[arr[i]]--;\n}\n```\n\n* 사용 : 정렬하는 숫자가 특정한 범위 내에 있을 때 사용\n\n  (Suffix Array 를 얻을 때, 시간복잡도 O(nlgn)으로 얻을 수 있음.)\n\n* 장점 : O(n) 의 시간복잡도\n\n* 단점 : 배열 사이즈 N 만큼 돌 때, 증가시켜주는 Counting 배열의 크기가 큼.\n\n  (메모리 낭비가 심함)', '2022-06-07', '8');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 이분 탐색(Binary Search)\n\n> 탐색 범위를 두 부분으로 분할하면서 찾는 방식\n\n처음부터 끝까지 돌면서 탐색하는 것보다 훨~~~씬 빠른 장점을 지님\n\n```\n* 시간복잡도\n전체 탐색 : O(N)\n이분 탐색 : O(logN)\n```\n\n<br>\n\n#### 진행 순서\n\n- 우선 정렬을 해야 함\n- left와 right로 mid 값 설정\n- mid와 내가 구하고자 하는 값과 비교\n- 구할 값이 mid보다 높으면 : left = mid+1\n  구할 값이 mid보다 낮으면 : right = mid - 1\n- left > right가 될 때까지 계속 반복하기\n\n<br>\n\n#### Code\n\n```java\npublic static int solution(int[] arr, int M) { // arr 배열에서 M을 찾자\n	\n    Arrays.sort(arr); // 정렬\n	\n    int start = 0;\n    int end = arr.length - 1;\n    int mid = 0;\n\n    while (start <= end) {\n        mid = (start + end) / 2;\n        if (M == arr[mid]) {\n            return mid;\n        }else if (arr[mid] < M) {\n            start = mid + 1;\n        }else if (M < arr[mid]) {\n            end = mid - 1;\n        }\n    }\n    throw new NoSuchElementException(\"타겟 존재하지 않음\");\n}\n```\n', '2022-06-07', '9');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# Hash Table 구현하기\n\n> 알고리즘 문제를 풀기위해 필수적으로 알아야 할 개념\n\n브루트 포스(완전 탐색)으로는 시간초과에 빠지게 되는 문제에서는 해시를 적용시켜야 한다.\n\n<br>\n\n[연습 문제 링크](<https://codeforces.com/contest/4/problem/C>)\n\n<br>\n\nN(1~100000)의 값만큼 문자열이 입력된다.\n\n처음 입력되는 문자열은 \"OK\", 들어온 적이 있던 문자열은 \"문자열+index\"로 출력하면 된다.\n\nex)\n\n##### Input\n\n```\n5\nabcd\nabc\nabcd\nabcd\nab\n```\n\n##### Output\n\n```\nOK\nOK\nabcd1\nabcd2\nOK\n```\n\n<br>\n\n문제를 이해하는 건 쉽다. 똑같은 문자열이 들어왔는지 체크해보고, 들어온 문자열은 인덱스 번호를 부여해서 출력해주면 된다.\n\n<br>\n\n하지만, 현재 N값은 최대 10만이다. 브루트 포스로 접근하면 N^2이 되므로 100억번의 연산이 필요해서 시간초과에 빠질 것이다. 따라서 **\'해시 테이블\'**을 이용해 해결해야 한다. \n\n<br>\n\n입력된 문자열 값을 해시 키로 변환시켜 저장하면서 최대한 시간을 줄여나가도록 구현해야 한다.\n\n이 문제는 해시 테이블을 알고리즘에서 적용시켜보기 위해 연습하기에 아주 좋은 문제 같다. 특히 삼성 상시 SW역량테스트 B형을 준비하는 사람들에게 추천하고 싶은 문제다. 해시 테이블 구현을 연습하기 딱 좋다.\n\n<br>\n\n<br>\n\n#### **해시 테이블 구현**\n\n해시 테이블은 탐색을 최대한 줄여주기 위해, input에 대한 key 값을 얻어내서 관리하는 방식이다.\n\n현재 최대 N 값은 10만이다. 이차원 배열로 1000/100으로 나누어 관리하면, 더 효율적일 것이다.\n\n충돌 값이 들어오는 것을 감안해 최대한 고려해서, 나는 두번째 배열 값에 4를 곱해서 선언한다.\n\n<br>\n\n```\n\nkey 값을 얻어서 저장할 때, 서로다른 문자열이라도 같은 key 값으로 들어올 수 있다. \n(이것이 해시에 대한 이론을 배울 때 나오는 충돌 현상이다.)\n\n충돌이 일어나는 것을 최대한 피해야하지만, 무조건 피할 수 있다는 보장은 없다. 그래서 두번째 배열 값을 조금 넉넉히 선언해두는 것이다.\n\n```\n\n이를 고려해 final 값으로 선언한 해시 값은 아래와 같다.\n\n```java\nstatic final int HASH_SIZE = 1000;\nstatic final int HASH_LEN = 400;\nstatic final int HASH_VAL = 17; // 소수로 할 것\n```\n\nHASH_VAL 값은 우리가 input 값을 받았을 때 해당하는 key 값을 얻을 때 활용한다.\n\n최대한 input 값들마다 key 값이 겹치지 않기 위해 하기 위해서는 소수로 선언해야한다. (그래서 보통 17, 19, 23으로 선언하는 것 같다.)\n\n<br>\n\nkey 값을 얻는 메소드 구현 방법은 아래와 같다. ( 각자 사람마다 다르므로 꼭 이게 정답은 아니다 )\n\n```java\npublic static int getHashKey(String str) {\n    \n    int key = 0;\n    \n    for (int i = 0; i < str.length(); i++) {\n        key = (key * HASH_VAL) + str.charAt(i);\n    }\n    \n    if(key < 0) key = -key; // 만약 key 값이 음수면 양수로 바꿔주기\n    \n    return key % HASH_SIZE;\n    \n}\n```\n\ninput 값을 매개변수로 받는다. 만약 string 값으로 들어온다고 가정해보자.\n\nstring 값의 한글자(character)마다 int형 값을 얻어낼 수 있다. 이를 활용해 string 값의 length만큼 반복문을 돌면서, 그 문자열만의 key 값을 만들어내는 것이 가능하다.\n\n우리는 이 key 값을 배열 인덱스로 활용할 것이기 때문에 음수면 안된다. 만약 key 값의 결과가 음수면 양수로 바꿔주는 조건문이 필요하다.\n\n<br>\n\n마지막으로 return 값으로 key를 우리가 선언한 HASH_SIZE로 나눈 나머지 값을 얻도록 한다.\n\n현재 계산된 key 값은 매우 크기 때문에 HASH_SIZE로 나눈 나머지 값으로 key를 활용할 것이다. (이 때문에 데이터가 많으면 많을수록 충돌되는 key값이 존재할 수 밖에 없다. - 우리는 최대한 충돌을 줄이면서 최적화시키기 위한 것..!)\n\n<br>\n\n이제 우리는 input으로 받은 string 값의 key 값을 얻었다.\n\n해당 key 값의 배열에서 이 값이 들어온 적이 있는지 확인하는 과정이 필요하다.\n\n<br>\n\n이제 우리는 모든 곳을 탐색할 필요없이, 이 key에 해당하는 배열에서만 확인하면 되므로 시간이 엄~~청 절약된다.\n\n<br>\n\n```java\nstatic int[][] data = new int[HASH_SIZE][HASH_LEN];\n\nstring str = \"apple\";\n\nint key = getHashKey(str); // apple에 대한 key 값 얻음\n\ndata[key][index]; // 이곳에 apple을 저장해서 관리하면 찾는 시간을 줄일 수 있는 것\n```\n\n여기서 HASH_SIZE가 1000이었고, 우리가 key 값을 리턴할 때 1000으로 나눈 나머지로 저장했으므로 이 안에서만 key 값이 들어오게 된다는 것을 이해할 수 있다.\n\n<br>\n\nArrayList로 2차원배열을 관리하면, 그냥 계속 추가해주면 되므로 구현이 간편하다.\n\n하지만 삼성 sw 역량테스트 B형처럼 라이브러리를 사용하지 못하는 경우에는, 배열로 선언해서 추가해나가야 한다. 또한 ArrayList 활용보다 배열이 훨씬 시간을 줄일 수 있기 때문에 되도록이면 배열을 이용하도록 하자\n\n<br>\n\n여기서 끝은 아니다. 이제 우리는 단순히 key 값만 받아온 것 뿐이다.\n\n해당 key 배열에서, apple이 들어온적이 있는지 없는지 체크해야한다. (문제에서 들어온적 있는건 숫자를 붙여서 출력해야 했기 때문이다.)\n\n<br>\n\n데이터의 수가 많으면 key 배열 안에서 다른 문자열이라도 같은 key로 저장되는 값들이 존재할 것이기 때문에 해당 key 배열을 돌면서 apple과 일치하는 문자열이 있는지 확인하는 과정이 필요하다.\n\n<br>\n\n따라서 key 값을 매개변수로 넣고 문자열이 들어왔던 적이 있는지 체크하는 함수를 구현하자\n\n```java\npublic static int checking(int key) {\n    \n    int len = length[key]; // 현재 key에 담긴 수 (같은 key 값으로 들어오는 문자열이 있을 수 있다)\n    \n    if(len != 0) { // 이미 들어온 적 있음\n        \n        for (int i = 0; i < len; i++) { // 이미 들어온 문자열이 해당 key 배열에 있는지 확인\n            if(str.equals(s_data[key][i])) {\n                data[key][i]++;\n                return data[key][i];\n            }\n        }\n        \n    }\n    \n    // 들어온 적이 없었으면 해당 key배열에서 문자열을 저장하고 길이 1 늘리기\n    s_data[key][length[key]++] = str;\n\n    return -1; // 처음으로 들어가는 경우 -1 리턴\n}\n```\n\nlength[] 배열은 HASH_SIZE만큼 선언된 것으로, key 값을 얻은 후, 처음 들어온 문자열일 때마다 숫자를 1씩 늘려서 해당 key 배열에 몇개의 데이터가 저장되어있는지 확인하는 공간이다.\n\n<br>\n\n**우리가 출력해야하는 조건은 처음 들어온건 \"OK\" 다시 또 들어온건 \"data + 들어온 수\"였다.**\n\n<br>\n\n- \"OK\"로 출력해야 하는 조건\n\n  > 해당 key의 배열 length가 0일 때는 무조건 처음 들어오는 데이터다.\n  >\n  > 또한 1이상일 때, 그 key 배열 안에서 만약 apple을 찾지 못했다면 이 또한 처음 들어오는 데이터다.\n\n<br>\n\n- \"data + 들어온 수\"로 출력해야 하는 조건\n\n  > 만약 1이상일 때 key 배열에서 apple 값을 찾았다면 이제 \'apple+들어온 수\'를 출력하도록 구현해야한다.\n\n<br>\n\n그래서 나는 3개의 배열을 선언해서 활용했다.\n\n```java\nstatic int[][] data = new int[HASH_SIZE][HASH_LEN];\nstatic int[] length = new int[HASH_SIZE];\nstatic String[][] s_data = new String[HASH_SIZE][HASH_LEN];\n```\n\ndata[][] 배열 : input으로 받는 문자열이 들어온 수를 저장하는 곳\n\nlength[] 배열 : key 값마다 들어온 수를 저장하는 곳\n\ns_data[][] 배열 : input으로 받은 문자열을 저장하는 곳 \n\n<br>\n\n진행 과정을 설명하면 아래와 같다. (apple - banana - abc - abc 순으로 입력되고, apple과 abc의 key값은 5로 같다고 가정하겠다.)\n\n<br>\n\n```\n1. apple이 들어옴. key 값을 얻으니 5가 나옴. length[5]는 0이므로 처음 들어온 데이터임. length[5]++하고 \"OK\"출력\n\n2. banana가 들어옴. key 값을 얻으니 3이 나옴. length[3]은 0이므로 처음 들어온 데이터임. length[3]++하고 \"OK\"출력\n\n<< 중요 >>\n3. abc가 들어옴. key 값을 얻으니 5가 나옴. length[5]는 0이 아님. 해당 key 값에 누가 들어온적이 있음. \nlength[5]만큼 반복문을 돌면서 s_data[key]의 배열과 abc가 일치하는 값이 있는지 확인함. 현재 length[5]는 1이고, s_data[key][0] = \"apple\"이므로 일치하는 값이 없기 때문에 length[5]를 1 증가시키고 s_data[key][length[5]]에 abc를 넣고 \"OK\"출력\n\n<< 중요 >>\n4. abc가 들어옴. key 값을 얻으니 5가 나옴. length[5] = 2임.\ns_data[key]를 2만큼 반복문을 돌면서 abc가 있는지 찾음. 1번째 인덱스 값에는 apple이 저장되어 있고 2번째 인덱스 값에서 abc가 일치함을 찾았음!!\n따라서 해당 data[key][index] 값을 1 증가시키고 이 값을 return 해주면서 메소드를 끝냄\n→ 메인함수에서 input으로 들어온 abc 값과 리턴값으로 나온 1을 붙여서 출력해주면 됨 (abc1)\n```\n\n<br>\n\n진행과정을 통해 어떤 방식으로 구현되는지 충분히 이해할 수 있을 것이다.\n\n<br>\n\n#### 전체 소스코드\n\n```java\npackage CodeForces;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Solution {\n	\n	static final int HASH_SIZE = 1000;\n	static final int HASH_LEN = 400;\n	static final int HASH_VAL = 17; // 소수로 할 것\n	\n	static int[][] data = new int[HASH_SIZE][HASH_LEN];\n	static int[] length = new int[HASH_SIZE];\n	static String[][] s_data = new String[HASH_SIZE][HASH_LEN];\n	static String str;\n	static int N;\n\n	public static void main(String[] args) throws Exception {\n		\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringBuilder sb = new StringBuilder();\n		\n		N = Integer.parseInt(br.readLine()); // 입력 수 (1~100000)\n		\n		for (int i = 0; i < N; i++) {\n			\n			str = br.readLine();\n			\n			int key = getHashKey(str);\n			int cnt = checking(key);\n			\n			if(cnt != -1) { // 이미 들어왔던 문자열\n				sb.append(str).append(cnt).append(\"\\n\");\n			}\n			else sb.append(\"OK\").append(\"\\n\");\n		}\n		\n		System.out.println(sb.toString());\n	}\n	\n	public static int getHashKey(String str) {\n		\n		int key = 0;\n		\n		for (int i = 0; i < str.length(); i++) {\n			key = (key * HASH_VAL) + str.charAt(i) + HASH_VAL;\n		}\n		\n		if(key < 0) key = -key; // 만약 key 값이 음수면 양수로 바꿔주기\n		\n		return key % HASH_SIZE;\n		\n	}\n	\n	public static int checking(int key) {\n		\n		int len = length[key]; // 현재 key에 담긴 수 (같은 key 값으로 들어오는 문자열이 있을 수 있다)\n		\n		if(len != 0) { // 이미 들어온 적 있음\n			\n			for (int i = 0; i < len; i++) { // 이미 들어온 문자열이 해당 key 배열에 있는지 확인\n				if(str.equals(s_data[key][i])) {\n					data[key][i]++;\n					return data[key][i];\n				}\n			}\n			\n		}\n		\n		// 들어온 적이 없었으면 해당 key배열에서 문자열을 저장하고 길이 1 늘리기\n		s_data[key][length[key]++] = str;\n\n		return -1; // 처음으로 들어가는 경우 -1 리턴\n	}\n\n}\n```\n', '2022-06-07', '10');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# DFS & BFS\n\n<br>\n\n그래프 알고리즘으로, 문제를 풀 때 상당히 많이 사용한다.\n\n경로를 찾는 문제 시, 상황에 맞게 DFS와 BFS를 활용하게 된다.\n\n<br>\n\n### DFS\n\n> 루트 노드 혹은 임의 노드에서 **다음 브랜치로 넘어가기 전에, 해당 브랜치를 모두 탐색**하는 방법\n\n**스택 or 재귀함수**를 통해 구현한다.\n\n<br>\n\n- 모든 경로를 방문해야 할 경우 사용에 적합\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif\" width=\"300\">\n\n##### 시간 복잡도\n\n- 인접 행렬 : O(V^2)\n- 인접 리스트 : O(V+E)\n\n> V는 접점, E는 간선을 뜻한다\n\n<br>\n\n##### Code\n\n```c\n#include <stdio.h>\n\nint map[1001][1001], dfs[1001];\n\nvoid init(int *, int size);\n\nvoid DFS(int v, int N) {\n\n	dfs[v] = 1;\n	printf(\"%d \", v);\n\n	for (int i = 1; i <= N; i++) {\n		if (map[v][i] == 1 && dfs[i] == 0) {\n			DFS(i, N);\n		}\n	}\n\n}\n\nint main(void) {\n\n	init(map, sizeof(map) / 4);\n	init(dfs, sizeof(dfs) / 4);\n\n	int N, M, V;\n	scanf(\"%d%d%d\", &N, &M, &V);\n\n	for (int i = 0; i < M; i++)\n	{\n		int start, end;\n		scanf(\"%d%d\", &start, &end);\n		map[start][end] = 1;\n		map[end][start] = 1;\n	}\n\n	DFS(V, N);\n\n	return 0;\n}\n\nvoid init(int *arr, int size) {\n	for (int i = 0; i < size; i++)\n	{\n		arr[i] = 0;\n	}\n}\n```\n\n<br>\n\n<br>\n\n### BFS\n\n> 루트 노드 또는 임의 노드에서 **인접한 노드부터 먼저 탐색**하는 방법\n\n**큐**를 통해 구현한다. (해당 노드의 주변부터 탐색해야하기 때문)\n\n<br>\n\n- 최소 비용(즉, 모든 곳을 탐색하는 것보다 최소 비용이 우선일 때)에 적합\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif\" width=\"300\">\n\n##### 시간 복잡도\n\n- 인접 행렬 : O(V^2)\n- 인접 리스트 : O(V+E)\n\n##### Code\n\n```c\n#include <stdio.h>\n\nint map[1001][1001], bfs[1001];\nint queue[1001];\n\nvoid init(int *, int size);\n\nvoid BFS(int v, int N) {\n	int front = 0, rear = 0;\n	int pop;\n\n	printf(\"%d \", v);\n	queue[rear++] = v;\n	bfs[v] = 1;\n\n	while (front < rear) {\n		pop = queue[front++];\n\n		for (int i = 1; i <= N; i++) {\n			if (map[pop][i] == 1 && bfs[i] == 0) {\n				printf(\"%d \", i);\n				queue[rear++] = i;\n				bfs[i] = 1;\n			}\n		}\n	}\n\n	return;\n}\n\nint main(void) {\n\n	init(map, sizeof(map) / 4);\n	init(bfs, sizeof(bfs) / 4);\n	init(queue, sizeof(queue) / 4);\n\n	int N, M, V;\n	scanf(\"%d%d%d\", &N, &M, &V);\n\n	for (int i = 0; i < M; i++)\n	{\n		int start, end;\n		scanf(\"%d%d\", &start, &end);\n		map[start][end] = 1;\n		map[end][start] = 1;\n	}\n\n	BFS(V, N);\n\n	return 0;\n}\n\nvoid init(int *arr, int size) {\n	for (int i = 0; i < size; i++)\n	{\n		arr[i] = 0;\n	}\n}\n```\n\n<br>\n\n**연습문제** : [[BOJ] DFS와 BFS](https://www.acmicpc.net/problem/1260)\n\n<br>\n\n##### [참고 자료]\n\n- [링크](https://developer-mac.tistory.com/64)', '2022-06-07', '11');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## LIS (Longest Increasing Sequence)\n\n> 최장 증가 수열 : 가장 긴 증가하는 부분 수열\n\n[ 7, **2**, **3**, 8, **4**, **5** ] → 해당 배열에서는 [2,3,4,5]가 LIS로 답은 4\n\n<br>\n\n##### 구현 방법 (시간복잡도)\n\n1. DP : O(N^2)\n2. Lower Bound : O(NlogN)\n\n<br>\n\n##### DP 활용 코드\n\n```java\nint arr[] = {7, 2, 3, 8, 4, 5};\nint dp[] = new int[arr.length]; // LIS 저장 배열\n\n\nfor(int i = 1; i < dp.length; i++) {\n    for(int j = i-1; j>=0; j--) {\n        if(arr[i] > arr[j]) {\n            dp[i] = (dp[i] < dp[j]+1) ? dp[j]+1 : dp[i];\n        }\n    }\n}\n\nfor (int i = 0; i < dp.length; i++) {\n	if(max < dp[i]) max = dp[i];\n}\n\n// 저장된 dp 배열 값 : [0, 0, 1, 2, 2, 3]\n// LIS : dp배열에 저장된 값 중 최대 값 + 1\n```\n\n<br>\n\n하지만, N^2으로 해결할 수 없는 문제라면? (ex. 배열의 길이가 최대 10만일 때..)\n\n이때는 Lower Bound를 활용한 LIS 구현을 진행해야한다.\n', '2022-06-07', '12');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## LCA(Lowest Common Ancestor) 알고리즘\n\n> 최소 공통 조상 찾는 알고리즘\n>\n> → 두 정점이 만나는 최초 부모 정점을 찾는 것!\n\n트리 형식이 아래와 같이 주어졌다고 하자\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/lca.png\" width=400>\n\n4와 5의 LCA는? → 4와 5의 첫 부모 정점은 \'2\'\n\n4와 6의 LCA는? → 첫 부모 정점은 root인 \'1\'\n\n***어떻게 찾죠?***\n\n해당 정점의 depth와 parent를 저장해두는 방식이다. 현재 그림에서의 depth는 아래와 같을 것이다.\n\n```\n[depth : 정점]\n0 → 1(root 정점)\n1 → 2, 3\n2 → 4, 5, 6, 7\n```\n\n<br>\n\nparent는 정점마다 가지는 부모 정점을 저장해둔다. 위의 예시에서 저장된 parent 배열은 아래와 같다.\n\n```java\n// 1 ~ 7번 정점 (root는 부모가 없기 때문에 0)\nint parent[] = {0, 1, 1, 2, 2, 3, 3}\n```\n\n이제\n\n이 두 배열을 활용해서 두 정점이 주어졌을 때 LCA를 찾을 수 있다. 과정은 아래와 같다.\n\n```java\n// 두 정점의 depth 확인하기\nwhile(true){\n	if(depth가 일치)\n		if(두 정점의 parent 일치?) LCA 찾음(종료)\n        else 두 정점을 자신의 parent 정점 값으로 변경\n    else // depth 불일치\n        더 depth가 깊은 정점을 해당 정점의 parent 정점으로 변경(depth가 감소됨)\n}\n```\n\n<br>\n\n트리 문제에서 공통 조상을 찾아야하는 문제나, 정점과 정점 사이의 이동거리 또는 방문경로를 저장해야 할 경우 사용하면 된다. ', '2022-06-07', '13');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 동적 계획법 (Dynamic Programming)\n\n> 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법\n\n<br>\n\n흔히 말하는 DP가 바로 \'동적 계획법\'\n\n**한 가지 문제**에 대해서, **단 한 번만 풀도록** 만들어주는 알고리즘이다.\n\n즉, 똑같은 연산을 반복하지 않도록 만들어준다. 실행 시간을 줄이기 위해 많이 이용되는 수학적 접근 방식의 알고리즘이라고 할 수 있다.\n\n<br>\n\n동적 계획법은 **Optimal Substructure**에서 효과를 발휘한다.\n\n*Optimal Substructure* : 답을 구하기 위해 이미 했던 똑같은 계산을 계속 반복하는 문제 구조\n\n<br>\n\n#### 접근 방식\n\n커다란 문제를 쉽게 해결하기 위해 작게 쪼개서 해결하는 방법인 분할 정복과 매우 유사하다. 하지만 간단한 문제로 만드는 과정에서 중복 여부에 대한 차이점이 존재한다.\n\n즉, 동적 계획법은 간단한 작은 문제들 속에서 \'계속 반복되는 연산\'을 활용하여 빠르게 풀 수 있는 것이 핵심이다.\n\n<br>\n\n#### 조건\n\n- 작은 문제에서 반복이 일어남\n- 같은 문제는 항상 정답이 같음\n\n이 두 가지 조건이 충족한다면, 동적 계획법을 이용하여 문제를 풀 수 있다.\n\n같은 문제가 항상 정답이 같고, 반복적으로 일어난다는 점을 활용해 메모이제이션(Memoization)으로 큰 문제를 해결해나가는 것이다.\n\n<br>\n\n*메모이제이션(Memoization)* : 한 번 계산한 문제는 다시 계산하지 않도록 저장해두고 활용하는 방식\n\n> 피보나치 수열에서 재귀를 활용하여 풀 경우, 같은 연산을 계속 반복함을 알 수 있다.\n>\n> 이때, 메모이제이션을 통해 같은 작업을 되풀이 하지 않도록 구현하면 효율적이다.\n\n```\nfibonacci(5) = fibonacci(4) + fibonacci(3)\nfibonacci(4) = fibonacci(3) + fibonacci(2)\nfibonacci(3) = fibonacci(2) + fibonacci(1)\n\n이처럼 같은 연산이 계속 반복적으로 이용될 때, 메모이제이션을 활용하여 값을 미리 저장해두면 효율적\n```\n\n피보나치 구현에 재귀를 활용했다면 시간복잡도는 O(2^n)이지만, 동적 계획법을 활용하면 O(N)으로 해결할 수 있다.\n\n<br>\n\n#### 구현 방식\n\n- Bottom-up : 작은 문제부터 차근차근 구하는 방법\n- Top-down : 큰 문제를 풀다가 풀리지 않은 작은 문제가 있다면 그때 해결하는 방법 (재귀 방식)\n\n> Bottom-up은 해결이 용이하지만, 가독성이 떨어짐\n>\n> Top-down은 가독성이 좋지만, 코드 작성이 힘듬\n\n<br>\n\n동적 계획법으로 문제를 풀 때는, 우선 작은 문제부터 해결해나가보는 것이 좋다.\n\n작은 문제들을 풀어나가다보면 이전에 구해둔 더 작은 문제들이 활용되는 것을 확인하게 된다. 이에 대한 규칙을 찾았을 때 **점화식**을 도출해내어 동적 계획법을 적용시키자\n\n<br>\n\n<br>\n\n##### [참고 자료]\n\n- [링크](https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95)', '2022-06-07', '14');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# 다익스트라(Dijkstra) 알고리즘\n\n<br>\n\n```\nDP를 활용한 최단 경로 탐색 알고리즘\n```\n\n<br>\n\n\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif\">\n\n<br>\n\n다익스트라 알고리즘은 특정한 정점에서 다른 모든 정점으로 가는 최단 경로를 기록한다.\n\n여기서 DP가 적용되는 이유는, 굳이 한 번 최단 거리를 구한 곳은 다시 구할 필요가 없기 때문이다. 이를 활용해 정점에서 정점까지 간선을 따라 이동할 때 최단 거리를 효율적으로 구할 수 있다.\n\n<br>\n\n다익스트라를 구현하기 위해 두 가지를 저장해야 한다.\n\n- 해당 정점까지의 최단 거리를 저장\n\n- 정점을 방문했는 지 저장\n\n시작 정점으로부터 정점들의 최단 거리를 저장하는 배열과, 방문 여부를 저장하는 것이다.\n\n<br>\n\n다익스트라의 알고리즘 순서는 아래와 같다.\n\n1. ##### 최단 거리 값은 무한대 값으로 초기화한다.\n\n   ```java\n   for(int i = 1; i <= n; i++){\n       distance[i] = Integer.MAX_VALUE;\n   }\n   ```\n\n2. ##### 시작 정점의 최단 거리는 0이다. 그리고 시작 정점을 방문 처리한다.\n\n   ```java\n   distance[start] = 0;\n   visited[start] = true;\n   ```\n\n3. ##### 시작 정점과 연결된 정점들의 최단 거리 값을 갱신한다.\n\n   ```java\n   for(int i = 1; i <= n; i++){\n       if(!visited[i] && map[start][i] != 0) {\n       	distance[i] = map[start][i];\n       }\n   }\n   ```\n\n4. ##### 방문하지 않은 정점 중 최단 거리가 최소인 정점을 찾는다.\n\n   ```java\n   int min = Integer.MAX_VALUE;\n   int midx = -1;\n   \n   for(int i = 1; i <= n; i++){\n       if(!visited[i] && distance[i] != Integer.MAX_VALUE) {\n       	if(distance[i] < min) {\n               min = distance[i];\n               midx = i;\n           }\n       }\n   }\n   ```\n\n5. ##### 찾은 정점을 방문 체크로 변경 후, 해당 정점과 연결된 방문하지 않은 정점의 최단 거리 값을 갱신한다.\n\n   ```java\n   visited[midx] = true;\n   for(int i = 1; i <= n; i++){\n       if(!visited[i] && map[midx][i] != 0) {\n       	if(distance[i] > distance[midx] + map[midx][i]) {\n               distance[i] = distance[midx] + map[midx][i];\n           }\n       }\n   }\n   ```\n\n6. ##### 모든 정점을 방문할 때까지 4~5번을 반복한다.\n\n<br>\n\n#### 다익스트라 적용 시 알아야할 점\n\n- 인접 행렬로 구현하면 시간 복잡도는 O(N^2)이다.\n\n- 인접 리스트로 구현하면 시간 복잡도는 O(N*logN)이다.\n\n  > 선형 탐색으로 시간 초과가 나는 문제는 인접 리스트로 접근해야한다. (우선순위 큐)\n\n- 간선의 값이 양수일 때만 가능하다.\n\n<br>\n\n<br>\n\n#### [참고사항]\n\n- [링크](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)\n- [링크](https://bumbums.tistory.com/4)', '2022-06-07', '15');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 비트마스크(BitMask)\n\n> 집합의 요소들의 구성 여부를 표현할 때 유용한 테크닉\n\n<br>\n\n##### *왜 비트마스크를 사용하는가?*\n\n- DP나 순열 등, 배열 활용만으로 해결할 수 없는 문제\n- 작은 메모리와 빠른 수행시간으로 해결이 가능 (But, 원소의 수가 많지 않아야 함)\n- 집합을 배열의 인덱스로 표현할 수 있음\n\n- 코드가 간결해짐\n\n<br>\n\n##### *비트(Bit)란?*\n\n> 컴퓨터에서 사용되는 데이터의 최소 단위 (0과 1)\n>\n> 2진법을 생각하면 편하다.\n\n<br>\n\n우리가 흔히 사용하는 10진수를 2진수로 바꾸면?\n\n`9(10진수) → 1001(2진수)`\n\n<br>\n\n#### 비트마스킹 활용해보기\n\n> 0과 1로, flag 활용하기\n\n[1, 2, 3, 4 ,5] 라는 집합이 있다고 가정해보자.\n\n여기서 임의로 몇 개를 골라 뽑아서 확인을 해야하는 상황이 주어졌다. (즉, 부분집합을 의미)\n\n```\n{1}, {2} , ... , {1,2} , ... , {1,2,5} , ... , {1,2,3,4,5}\n```\n\n물론, 간단히 for문 돌려가며 배열에 저장하며 경우의 수를 구할 순 있다.\n\n하지만 비트마스킹을 하면, 각 요소를 인덱스처럼 표현하여 효율적인 접근이 가능하다.\n\n```\n[1,2,3,4,5] → 11111\n[2,3,4,5]   → 11110\n[1,2,5]     → 10011\n[2]         → 00010\n```\n\n집합의 i번째 요소가 존재하면 `1`, 그렇지 않으면 `0`을 의미하는 것이다.\n\n이러한 2진수는 다시 10진수로 변환도 가능하다.\n\n`11111`은 10진수로 31이므로, 부분집합을 **정수를 통해 나타내는 것**이 가능하다는 것을 알 수 있다.\n\n> 31은 [1,2,3,4,5] 전체에 해당하는 부분집합에 해당한다는 의미!\n\n이로써, 해당 부분집합에 i를 추가하고 싶을때 i번째 비트를 1로만 바꿔주면 표현이 가능해졌다.\n\n이런 행위는 **비트 연산**을 통해 제어가 가능하다.\n\n<br>\n\n#### 비트 연산\n\n> AND, OR, XOR, NOT, SHIFT\n\n- AND(&) : 대응하는 두 비트가 모두 1일 때, 1 반환\n\n- OR(|) : 대응하는 두 비트 중 모두 1이거나 하나라도 1일때, 1 반환\n\n- XOR(^) : 대응하는 두 비트가 서로 다를 때, 1 반환\n\n- NOT(~) : 비트 값 반전하여 반환\n\n- SHIFT(>>, <<) : 왼쪽 혹은 오른쪽으로 비트 옮겨 반환\n\n  - 왼쪽 시프트 : `A * 2^B`\n  - 오른쪽 시프트 : `A / 2^B`\n\n  ```\n  [왼  쪽] 0001 → 0010 → 0100 → 1000 : 1 → 2 → 4 → 8\n  [오른쪽] 1000 → 0100 → 0010 → 0001 : 8 → 4 → 2 → 1\n  ```\n\n<br>\n\n비트연산 연습문제 : [백준 12813](https://www.acmicpc.net/problem/12813)\n\n##### 구현 코드(C)\n\n```C\n#include <stdio.h>\n\nint main(void) {\n	unsigned char A[100001] = { 0, };\n	unsigned char B[100001] = { 0, };\n	unsigned char ret[100001] = { 0, };\n	int i;\n\n	scanf(\"%s %s\", &A, &B);\n\n    // AND\n	for (i = 0; i < 100000; i++)\n		ret[i] = A[i] & B[i];\n	puts(ret);\n    \n    // OR\n	for (i = 0; i < 100000; i++)\n		ret[i] = A[i] | B[i];\n	puts(ret);\n\n    // XOR\n	for (i = 0; i < 100000; i++)\n		ret[i] = A[i] != B[i] ? \'1\' : \'0\';\n	puts(ret);\n\n    // ~A\n	for (i = 0; i < 100000; i++)\n		ret[i] = A[i] == \'1\' ? \'0\' : \'1\';\n	puts(ret);\n\n    // ~B\n	for (i = 0; i < 100000; i++)\n		ret[i] = B[i] == \'1\' ? \'0\' : \'1\';\n	puts(ret);\n\n	return 0;\n}\n```\n\n<br>\n\n연습이 되었다면, 다시 비트마스크로 돌아와 비트연산을 활용해보자\n\n크게 삽입, 삭제, 조회로 나누어 진다.\n\n<br>\n\n#### 1.삽입\n\n현재 이진수로 `10101`로 표현되고 있을 때, i번째 비트 값을 1로 변경하려고 한다.\n\ni = 3일 때 변경 후에는 `11101`이 나와야 한다. 이때는 **OR연산을 활용**한다.\n\n```\n10101 | 1 << 3\n```\n\n`1 << 3`은 `1000`이므로 `10101 | 01000`이 되어 `11101`을 만들 수 있다.\n\n<br>\n\n#### 2.삭제\n\n반대로 0으로 변경하려면, **AND연산과 NOT 연산을 활용**한다.\n\n```\n11101 & ~1 << 3\n```\n\n`~1 << 3`은 `10111`이므로, `11101 & 10111`이 되어 `10101`을 만들 수 있다.\n\n<br>\n\n#### 3.조회\n\ni번째 비트가 무슨 값인지 알려면, **AND연산을 활용**한다.\n\n```\n10101 & 1 << i\n\n3번째 비트 값 : 10101 & (1 << 3) = 10101 & 01000 → 0\n4번째 비트 값 : 10101 & (1 << 4) = 10101 & 10000 → 10000\n```\n\n이처럼 결과값이 0이 나왔을 때는 i번째 비트 값이 0인 것을 파악할 수 있다. (반대로 0이 아니면 무조건 1인 것)\n\n이러한 방법을 활용하여 문제를 해결하는 것이 비트마스크다.\n\n<br>\n\n비트마스크 연습문제 : [백준 2098](https://www.acmicpc.net/problem/2098)\n\n<br>\n\n해당 문제는 모든 도시를 한 번만 방문하면서 다시 시작점으로 돌아오는 최소 거리 비용을 구해야한다.\n\n완전탐색으로 답을 구할 수는 있지만, N이 최대 16이기 때문에 16!으로 시간초과에 빠지게 된다.\n\n따라서 DP를 활용해야 하며, 방문 여부를 배열로 관리하기 힘드므로 비트마스크를 활용하면 좋은 문제다.\n\n<br>\n\n<br>\n\n##### [참고자료]\n\n- [링크](https://mygumi.tistory.com/361)\n', '2022-06-07', '16');
insert into cscontent (cs_content, cs_regdate, cs_code) values('### 배열 (Array)\n\n---\n\n- C++에서 사이즈 구하기 \n\n```\nint arr[] = { 1, 2, 3, 4, 5, 6, 7 }; \nint n = sizeof(arr) / sizeof(arr[0]); // 7\n```\n\n<br/>\n\n<br/>\n\n1. #### 배열 회전 프로그램\n\n\n\n![img](https://t1.daumcdn.net/cfile/tistory/99AFA23F5BE8F31B0C)\n\n\n\n*전체 코드는 각 하이퍼링크를 눌러주시면 이동됩니다.*\n\n<br/>\n\n- [기본적인 회전 알고리즘 구현](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/code/rotate_array.cpp)\n\n  > temp를 활용해서 첫번째 인덱스 값을 저장 후\n  > arr[0]~arr[n-1]을 각각 arr[1]~arr[n]의 값을 주고, arr[n]에 temp를 넣어준다.\n  >\n  > ```\n  > void leftRotatebyOne(int arr[], int n){\n  >     int temp = arr[0], i;\n  >     for(i = 0; i < n-1; i++){\n  >         arr[i] = arr[i+1];\n  >     }\n  >     arr[i] = temp;\n  > }\n  > ```\n  >\n  > 이 함수를 활용해 원하는 회전 수 만큼 for문을 돌려 구현이 가능\n\n  <br/>\n\n- [저글링 알고리즘 구현](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/code/juggling_array.cpp)\n\n  > ![ArrayRotation](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/arra.jpg)\n  >\n  > 최대공약수 gcd를 이용해 집합을 나누어 여러 요소를 한꺼번에 이동시키는 것\n  >\n  > 위 그림처럼 배열이 아래와 같다면\n  >\n  > arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}\n  >\n  > 1,2,3을 뒤로 옮길 때, 인덱스를 3개씩 묶고 회전시키는 방법이다.\n  >\n  > a) arr [] -> { **4** 2 3 **7** 5 6 **10** 8 9 **1** 11 12}\n  >\n  > b) arr [] -> {4 **5** 3 7 **8** 6 10 **11** 9 1 **2** 12}\n  >\n  > c) arr [] -> {4 5 **6**  7 8 **9** 10 11 **12** 1 2 **3** }\n\n  <br/>\n\n- [역전 알고리즘 구현](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/code/reversal_array.cpp)\n\n  > 회전시키는 수에 대해 구간을 나누어 reverse로 구현하는 방법\n  >\n  > d = 2이면\n  >\n  > 1,2 / 3,4,5,6,7로 구간을 나눈다.\n  >\n  > 첫번째 구간 reverse -> 2,1\n  >\n  > 두번째 구간 reverse -> 7,6,5,4,3\n  >\n  > 합치기 -> 2,1,7,6,5,4,3\n  >\n  > 합친 배열을 reverse -> **3,4,5,6,7,1,2**\n  >\n  >\n  >\n  > - swap을 통한 reverse\n  >\n  > ```\n  > void reverseArr(int arr[], int start, int end){\n  >     \n  >     while (start < end){\n  >         int temp = arr[start];\n  >         arr[start] = arr[end];\n  >         arr[end] = temp;\n  >         \n  >         start++;\n  >         end--;\n  >     }\n  > }\n  > ```\n  >\n  >\n  >\n  > - 구간을 d로 나누었을 때 역전 알고리즘 구현\n  >\n  > ```\n  > void rotateLeft(int arr[], int d, int n){\n  >     reverseArr(arr, 0, d-1);\n  >     reverseArr(arr, d, n-1);\n  >     reverseArr(arr, 0, n-1);\n  > }\n  > ```\n\n<br/>\n\n<br/>\n\n2. #### 배열의 특정 최대 합 구하기\n\n\n\n**예시)** arr[i]가 있을 때, i*arr[i]의 Sum이 가장 클 때 그 값을 출력하기 \n\n(회전하면서 최대값을 찾아야한다.)\n\n```\nInput: arr[] = {1, 20, 2, 10}\nOutput: 72\n\n2번 회전했을 때 아래와 같이 최대값이 나오게 된다.\n{2, 10, 1, 20}\n20*3 + 1*2 + 10*1 + 2*0 = 72\n\nInput: arr[] = {10, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nOutput: 330\n\n9번 회전했을 때 아래와 같이 최대값이 나오게 된다.\n{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n0*1 + 1*2 + 2*3 ... 9*10 = 330\n```\n\n<br/>\n\n##### 접근 방법\n\narr[i]의 전체 합과 i*arr[i]의 전체 합을 저장할 변수 선언\n\n최종 가장 큰 sum 값을 저장할 변수 선언\n\n배열을 회전시키면서 i*arr[i]의 합의 값을 저장하고, 가장 큰 값을 저장해서 출력하면 된다.\n\n<br/>\n\n##### 해결법\n\n```\n회전 없이 i*arr[i]의 sum을 저장한 값\nR0 = 0*arr[0] + 1*arr[1] +...+ (n-1)*arr[n-1]\n\n\n1번 회전하고 i*arr[i]의 sum을 저장한 값\nR1 = 0*arr[n-1] + 1*arr[0] +...+ (n-1)*arr[n-2]\n\n이 두개를 빼면?\nR1 - R0 = arr[0] + arr[1] + ... + arr[n-2] - (n-1)*arr[n-1]\n\n2번 회전하고 i*arr[i]의 sum을 저장한 값\nR2 = 0*arr[n-2] + 1*arr[n-1] +...+ (n?1)*arr[n-3]\n\n1번 회전한 값과 빼면?\nR2 - R1 = arr[0] + arr[1] + ... + arr[n-3] - (n-1)*arr[n-2] + arr[n-1]\n\n\n여기서 규칙을 찾을 수 있음.\n\nRj - Rj-1 = arrSum - n * arr[n-j]\n\n이를 활용해서 몇번 회전했을 때 최대값이 나오는 지 구할 수 있다.\n```\n\n[구현 소스 코드 링크](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/code/maxvalue_array.cpp)\n\n<br/>\n\n<br/>\n\n3. #### 특정 배열을 arr[i] = i로 재배열 하기\n\n**예시)** 주어진 배열에서 arr[i] = i이 가능한 것만 재배열 시키기\n\n```\nInput : arr = {-1, -1, 6, 1, 9, 3, 2, -1, 4, -1}\nOutput : [-1, 1, 2, 3, 4, -1, 6, -1, -1, 9]\n\nInput : arr = {19, 7, 0, 3, 18, 15, 12, 6, 1, 8,\n              11, 10, 9, 5, 13, 16, 2, 14, 17, 4}\nOutput : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \n         11, 12, 13, 14, 15, 16, 17, 18, 19]\n```\n\narr[i] = i가 없으면 -1로 채운다.\n\n\n\n##### 접근 방법\n\narr[i]가 -1이 아니고, arr[i]이 i가 아닐 때가 우선 조건\n\n해당 arr[i] 값을 저장(x)해두고, 이 값이 x일 때 arr[x]를 탐색\n\narr[x] 값을 저장(y)해두고, arr[x]가 -1이 아니면서 arr[x]가 x가 아닌 동안을 탐색\n\narr[x]를 x값으로 저장해주고, 기존의 x를 y로 수정\n\n```\nint fix(int A[], int len){\n    \n    for(int i = 0; i < len; i++) {\n        \n        \n        if (A[i] != -1 && A[i] != i){ // A[i]가 -1이 아니고, i도 아닐 때\n            \n            int x = A[i]; // 해당 값을 x에 저장\n            \n            while(A[x] != -1 && A[x] != x){ // A[x]가 -1이 아니고, x도 아닐 때\n                \n                int y = A[x]; // 해당 값을 y에 저장\n                A[x] = x; \n                \n                x = y;\n            }\n            \n            A[x] = x;\n            \n            if (A[i] != i){\n                A[i] = -1;\n            }\n        }\n    }\n    \n}\n```\n\n[구현 소스 코드 링크](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/code/rearrange_array.cpp)\n\n<br/>\n\n<br/>', '2022-06-07', '17');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## Array vs ArrayList vs LinkedList\n\n<br>\n\n세 자료구조를 한 문장으로 정의하면 아래와 같이 말할 수 있다.\n\n\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/995E66395B1CFD7D10\">\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/99250A345B1CFD690C\">\n\n<br>\n\n- **Array**는 index로 빠르게 값을 찾는 것이 가능함\n- **LinkedList**는 데이터의 삽입 및 삭제가 빠름\n- **ArrayList**는 데이터를 찾는데 빠르지만, 삽입 및 삭제가 느림\n\n<br>\n\n좀 더 자세히 비교하면?\n\n<br>\n\n우선 배열(Array)는 **선언할 때 크기와 데이터 타입을 지정**해야 한다.\n\n```java\nint arr[10];\nString arr[5];\n```\n\n이처럼, **array**은 메모리 공간에 할당할 사이즈를 미리 정해놓고 사용하는 자료구조다.\n\n따라서 계속 데이터가 늘어날 때, 최대 사이즈를 알 수 없을 때는 사용하기에 부적합하다.\n\n또한 중간에 데이터를 삽입하거나 삭제할 때도 매우 비효율적이다.\n\n4번째 index 값에 새로운 값을 넣어야 한다면? 원래값을 뒤로 밀어내고 해당 index에 덮어씌워야 한다. 기본적으로 사이즈를 정해놓은 배열에서는 해결하기엔 부적합한 점이 많다.\n\n대신, 배열을 사용하면 index가 존재하기 때문에 위치를 바로 알 수 있어 검색에 편한 장점이 있다.\n\n<br>\n\n이를 해결하기 위해 나온 것이 **List**다.\n\nList는 array처럼 **크기를 정해주지 않아도 된다**. 대신 array에서 index가 중요했다면, List에서는 순서가 중요하다.\n\n크기가 정해져있지 않기 때문에, 중간에 데이터를 추가하거나 삭제하더라도 array에서 갖고 있던 문제점을 해결 가능하다. index를 가지고 있으므로 검색도 빠르다.\n\n하지만, 중간에 데이터를 추가 및 삭제할 때 시간이 오래걸리는 단점이 존재한다. (더하거나 뺄때마다 줄줄이 당겨지거나 밀려날 때 진행되는 연산이 추가, 메모리도 낭비..)\n\n<br>\n\n그렇다면 **LinkedList**는?\n\n연결리스트에는 단일, 다중 등 여러가지가 존재한다.\n\n종류가 무엇이든, **한 노드에 연결될 노드의 포인터 위치를 가리키는 방식**으로 되어있다.\n\n> 단일은 뒤에 노드만 가리키고, 다중은 앞뒤 노드를 모두 가리키는 차이\n\n<br>\n\n이런 방식을 활용하면서, 데이터의 중간에 삽입 및 삭제를 하더라도 전체를 돌지 않아도 이전 값과 다음값이 가르켰던 주소값만 수정하여 연결시켜주면 되기 때문에 빠르게 진행할 수 있다.\n\n이렇게만 보면 가장 좋은 방법 같아보이지만, `List의 k번째 값을 찾아라`에서는 비효율적이다.\n\n<br>\n\narray나 arrayList에서 index를 갖고 있기 때문에 검색이 빠르지만, LinkedList는 처음부터 살펴봐야하므로(순차) 검색에 있어서는 시간이 더 걸린다는 단점이 존재한다. \n\n<br>\n\n따라서 상황에 맞게 자료구조를 잘 선택해서 사용하는 것이 중요하다.', '2022-06-07', '18');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 스택(Stack)\n\n입력과 출력이 한 곳(방향)으로 제한\n\n##### LIFO (Last In First Out, 후입선출) : 가장 나중에 들어온 것이 가장 먼저 나옴\n\n<br>\n\n***언제 사용?***\n\n함수의 콜스택, 문자열 역순 출력, 연산자 후위표기법\n\n<br>\n\n데이터 넣음 : push() \n\n데이터 최상위 값 뺌 : pop()\n\n비어있는 지 확인 : isEmpty()\n\n꽉차있는 지 확인 : isFull()\n\n+SP\n\n<br>\n\npush와 pop할 때는 해당 위치를 알고 있어야 하므로 기억하고 있는 \'스택 포인터(SP)\'가 필요함\n\n스택 포인터는 다음 값이 들어갈 위치를 가리키고 있음 (처음 기본값은 -1)\n\n```java\nprivate int sp = -1;\n```\n\n<br>\n\n##### push\n\n```java\npublic void push(Object o) {\n    if(isFull(o)) {\n        return;\n    }\n    \n    stack[++sp] = o;\n}\n```\n\n스택 포인터가 최대 크기와 같으면 return\n\n아니면 스택의 최상위 위치에 값을 넣음\n\n<br>\n\n##### pop\n\n```java\npublic Object pop() {\n    \n    if(isEmpty(sp)) {\n        return null;\n    }\n    \n    Object o = stack[sp--];\n    return o;\n    \n}\n```\n\n스택 포인터가 0이 되면 null로 return;\n\n아니면 스택의 최상위 위치 값을 꺼내옴\n\n<br>\n\n##### isEmpty\n\n```java\nprivate boolean isEmpty(int cnt) {\n    return sp == -1 ? true : false;\n}\n```\n\n입력 값이 최초 값과 같다면 true, 아니면 false\n\n<br>\n\n##### isFull\n\n```java\nprivate boolean isFull(int cnt) {\n    return sp + 1 == MAX_SIZE ? true : false;\n}\n```\n\n스택 포인터 값+1이 MAX_SIZE와 같으면 true, 아니면 false\n\n<br>\n\n<br>\n\n#### 동적 배열 스택\n\n위처럼 구현하면 스택에는 MAX_SIZE라는 최대 크기가 존재해야 한다\n\n(스택 포인터와 MAX_SIZE를 비교해서 isFull 메소드로 비교해야되기 때문!)\n\n<br>\n\n최대 크기가 없는 스택을 만드려면?\n\n> arraycopy를 활용한 동적배열 사용\n\n<br>\n\n```java\npublic void push(Object o) {\n    \n    if(isFull(sp)) {\n        \n        Object[] arr = new Object[MAX_SIZE * 2];\n        System.arraycopy(stack, 0, arr, 0, MAX_SIZE);\n        stack = arr;\n        MAX_SIZE *= 2; // 2배로 증가\n    }\n    \n    stack[sp++] = o;\n}\n```\n\n기존 스택의 2배 크기만큼 임시 배열(arr)을 만들고\n\narraycopy를 통해 stack의 인덱스 0부터 MAX_SIZE만큼을 arr 배열의 0번째부터 복사한다\n\n복사 후에 arr의 참조값을 stack에 덮어씌운다\n\n마지막으로 MAX_SIZE의 값을 2배로 증가시켜주면 된다.\n\n<br>\n\n이러면, 스택이 가득찼을 때 자동으로 확장되는 스택을 구현할 수 있음\n\n<br>\n\n#### 스택을 연결리스트로 구현해도 해결 가능\n\n```java\npublic class Node {\n\n    public int data;\n    public Node next;\n\n    public Node() {\n    }\n\n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n```\n\n```java\npublic class Stack {\n    private Node head;\n    private Node top;\n\n    public Stack() {\n        head = top = null;\n    }\n\n    private Node createNode(int data) {\n        return new Node(data);\n    }\n\n    private boolean isEmpty() {\n        return top == null ? true : false;\n    }\n\n    public void push(int data) {\n        if (isEmpty()) { // 스택이 비어있다면\n            head = createNode(data);\n            top = head;\n        }\n        else { //스택이 비어있지 않다면 마지막 위치를 찾아 새 노드를 연결시킨다.\n            Node pointer = head;\n\n            while (pointer.next != null)\n                pointer = pointer.next;\n\n            pointer.next = createNode(data);\n            top = pointer.next;\n        }\n    }\n\n    public int pop() {\n        int popData;\n        if (!isEmpty()) { // 스택이 비어있지 않다면!! => 데이터가 있다면!!\n            popData = top.data; // pop될 데이터를 미리 받아놓는다.\n            Node pointer = head; // 현재 위치를 확인할 임시 노드 포인터\n\n            if (head == top) // 데이터가 하나라면\n                head = top = null;\n            else { // 데이터가 2개 이상이라면\n                while (pointer.next != top) // top을 가리키는 노드를 찾는다.\n                    pointer = pointer.next;\n\n                pointer.next = null; // 마지막 노드의 연결을 끊는다.\n                top = pointer; // top을 이동시킨다.\n            }\n            return popData;\n        }\n        return -1; // -1은 데이터가 없다는 의미로 지정해둠.\n\n    }\n\n}\n```\n\n<br>\n\n<br>\n\n<br>\n\n## 큐(Queue)\n\n입력과 출력을 한 쪽 끝(front, rear)으로 제한\n\n##### FIFO (First In First Out, 선입선출) : 가장 먼저 들어온 것이 가장 먼저 나옴\n\n<br>\n\n***언제 사용?***\n\n버퍼, 마구 입력된 것을 처리하지 못하고 있는 상황, BFS\n\n<br>\n\n큐의 가장 첫 원소를 front, 끝 원소를 rear라고 부름\n\n큐는 **들어올 때 rear로 들어오지만, 나올 때는 front부터 빠지는 특성**을 가짐\n\n접근방법은 가장 첫 원소와 끝 원소로만 가능\n\n<br>\n\n데이터 넣음 : enQueue()\n\n데이터 뺌 : deQueue()\n\n비어있는 지 확인 : isEmpty()\n\n꽉차있는 지 확인 : isFull()\n\n<br>\n\n데이터를 넣고 뺄 때 해당 값의 위치를 기억해야 함. (스택에서 스택 포인터와 같은 역할)\n\n이 위치를 기억하고 있는 게 front와 rear\n\nfront : deQueue 할 위치 기억\n\nrear : enQueue 할 위치 기억\n\n<br>\n\n##### 기본값\n\n```java\nprivate int size = 0; \nprivate int rear = -1; \nprivate int front = -1;\n\nQueue(int size) { \n    this.size = size;\n    this.queue = new Object[size];\n}\n```\n\n<br>\n\n<br>\n\n##### enQueue\n\n```java\npublic void enQueue(Object o) {\n    \n    if(isFull()) {\n        return;\n    }\n    \n    queue[++rear] = o;\n}\n```\n\nenQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow\n\n아니면 rear에 값 넣고 1 증가\n\n<br>\n\n<br>\n\n##### deQueue\n\n```java\npublic Object deQueue(Object o) {\n    \n    if(isEmpty()) { \n        return null;\n    }\n    \n    Object o = queue[front];\n    queue[front++] = null;\n    return o;\n}\n```\n\ndeQueue를 할 때 공백이면 underflow\n\nfront에 위치한 값을 object에 꺼낸 후, 꺼낸 위치는 null로 채워줌\n\n<br>\n\n#####  isEmpty\n\n```java\npublic boolean isEmpty() {\n    return front == rear;\n}\n```\n\nfront와 rear가 같아지면 비어진 것\n\n<br>\n\n##### isFull\n\n```java\npublic boolean isFull() {\n    return (rear == queueSize-1);\n}\n```\n\nrear가 사이즈-1과 같아지면 가득찬 것\n\n<br>\n\n---\n\n일반 큐의 단점 : 큐에 빈 메모리가 남아 있어도, 꽉 차있는것으로 판단할 수도 있음\n\n(rear가 끝에 도달했을 때)\n\n<br>\n\n이를 개선한 것이 **\'원형 큐\'**\n\n논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주함!\n\n<br>\n\n원형 큐는 초기 공백 상태일 때 front와 rear가 0\n\n공백, 포화 상태를 쉽게 구분하기 위해 **자리 하나를 항상 비워둠**\n\n```\n(index + 1) % size로 순환시킨다\n```\n\n<br>\n\n##### 기본값\n\n```java\nprivate int size = 0; \nprivate int rear = 0; \nprivate int front = 0;\n\nQueue(int size) { \n    this.size = size;\n    this.queue = new Object[size];\n}\n```\n\n<br>\n\n##### enQueue\n\n```java\npublic void enQueue(Object o) {\n    \n    if(isFull()) {\n        return;\n    }\n    \n    rear = (++rear) % size;\n    queue[rear] = o;\n}\n```\n\nenQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow\n\n<br>\n\n<br>\n\n##### deQueue\n\n```java\npublic Object deQueue(Object o) {\n    \n    if(isEmpty()) { \n        return null;\n    }\n    \n    front = (++front) % size;\n    Object o = queue[front];\n    return o;\n}\n```\n\ndeQueue를 할 때 공백이면 underflow\n\n<br>\n\n#####  isEmpty\n\n```java\npublic boolean isEmpty() {\n    return front == rear;\n}\n```\n\nfront와 rear가 같아지면 비어진 것\n\n<br>\n\n##### isFull\n\n```java\npublic boolean isFull() {\n    return ((rear+1) % size == front);\n}\n```\n\nrear+1%size가 front와 같으면 가득찬 것\n\n<br>\n\n원형 큐의 단점 : 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한\n\n<br>\n\n<br>\n\n이를 개선한 것이 \'연결리스트 큐\'\n\n##### 연결리스트 큐는 크기가 제한이 없고 삽입, 삭제가 편리\n\n<br>\n\n##### enqueue 구현\n\n```java\npublic void enqueue(E item) {\n    Node oldlast = tail; // 기존의 tail 임시 저장\n    tail = new Node; // 새로운 tail 생성\n    tail.item = item;\n    tail.next = null;\n    if(isEmpty()) head = tail; // 큐가 비어있으면 head와 tail 모두 같은 노드 가리킴\n    else oldlast.next = tail; // 비어있지 않으면 기존 tail의 next = 새로운 tail로 설정\n}\n```\n\n> - 데이터 추가는 끝 부분인 tail에 한다.\n>\n> - 기존의 tail는 보관하고, 새로운 tail 생성\n>\n> - 큐가 비었으면 head = tail를 통해 둘이 같은 노드를 가리키도록 한다.\n> - 큐가 비어있지 않으면, 기존 tail의 next에 새로만든 tail를 설정해준다.\n\n<br>\n\n##### dequeue 구현\n\n```java\npublic T dequeue() {\n    // 비어있으면\n    if(isEmpty()) {\n        tail = head;\n        return null;\n    }\n    // 비어있지 않으면\n    else {\n        T item = head.item; // 빼낼 현재 front 값 저장\n        head = head.next; // front를 다음 노드로 설정\n        return item;\n    }\n}\n```\n\n> - 데이터는 head로부터 꺼낸다. (가장 먼저 들어온 것부터 빼야하므로)\n> - head의 데이터를 미리 저장해둔다.\n> - 기존의 head를 그 다음 노드의 head로 설정한다.\n> - 저장해둔 데이터를 return 해서 값을 빼온다.\n\n<br>\n\n이처럼 삽입은 tail, 제거는 head로 하면서 삽입/삭제를 스택처럼 O(1)에 가능하도록 구현이 가능하다.', '2022-06-07', '19');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## [자료구조] 힙(Heap)\n\n<br>\n\n##### 알아야할 것\n\n> 1.힙의 개념\n>\n> 2.힙의 삽입 및 삭제\n\n<br>\n\n힙은, 우선순위 큐를 위해 만들어진 자료구조다.\n\n먼저 **우선순위 큐**에 대해서 간략히 알아보자 \n\n<br>\n\n**우선순위 큐** : 우선순위의 개념을 큐에 도입한 자료구조\n\n> 데이터들이 우선순위를 가지고 있음. 우선순위가 높은 데이터가 먼저 나감\n\n스택은 LIFO, 큐는 FIFO\n\n<br>\n\n##### 언제 사용?\n\n> 시뮬레이션 시스템, 작업 스케줄링, 수치해석 계산\n\n우선순위 큐는 배열, 연결리스트, 힙으로 구현 (힙으로 구현이 가장 효율적!)\n\n힙 → 삽입 : O(logn) , 삭제 : O(logn)\n\n<br>\n\n<br>\n\n### 힙(Heap)\n\n---\n\n완전 이진 트리의 일종\n\n> 여러 값 중, 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조\n\n반정렬 상태\n\n힙 트리는 중복된 값 허용 (이진 탐색 트리는 중복값 허용X)\n\n<br>\n\n#### 힙 종류\n\n###### 최대 힙(max heap)\n\n  부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리\n\n###### 최소 힙(min heap)\n\n  부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리\n\n <img src=\"https://t1.daumcdn.net/cfile/tistory/17084F504DA9895214\">\n\n<br>\n\n#### 구현\n\n---\n\n힙을 저장하는 표준적인 자료구조는 `배열`\n\n구현을 쉽게 하기 위해 배열의 첫번째 인덱스인 0은 사용되지 않음\n\n특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않음\n\n(ex. 루트 노드(1)의 오른쪽 노드 번호는 항상 3)\n\n <br>\n\n##### 부모 노드와 자식 노드 관계\n\n```\n왼쪽 자식 index = (부모 index) * 2\n\n오른쪽 자식 index = (부모 index) * 2 + 1\n\n부모 index = (자식 index) / 2\n```\n\n<br>\n\n#### 힙의 삽입\n\n1.힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입\n\n2.새로운 노드를 부모 노드들과 교환\n\n<br>\n\n###### 최대 힙 삽입 구현\n\n```java\nvoid insert_max_heap(int x) {\n    \n    maxHeap[++heapSize] = x; \n    // 힙 크기를 하나 증가하고, 마지막 노드에 x를 넣음\n    \n    for( int i = heapSize; i > 1; i /= 2) {\n        \n        // 마지막 노드가 자신의 부모 노드보다 크면 swap\n        if(maxHeap[i/2] < maxHeap[i]) {\n            swap(i/2, i);\n        } else {\n            break;\n        }\n        \n    }\n}\n```\n\n부모 노드는 자신의 인덱스의 /2 이므로, 비교하고 자신이 더 크면 swap하는 방식\n\n<br>\n\n#### 힙의 삭제\n\n1.최대 힙에서 최대값은 루트 노드이므로 루트 노드가 삭제됨\n(최대 힙에서 삭제 연산은 최대값 요소를 삭제하는 것)\n\n2.삭제된 루트 노드에는 힙의 마지막 노드를 가져옴\n\n3.힙을 재구성\n\n<br>\n\n###### 최대 힙 삭제 구현\n\n```java\nint delete_max_heap() {\n    \n    if(heapSize == 0) // 배열이 비어있으면 리턴\n        return 0;\n    \n    int item = maxHeap[1]; // 루트 노드의 값을 저장\n    maxHeap[1] = maxHeap[heapSize]; // 마지막 노드 값을 루트로 이동\n    maxHeap[heapSize--] = 0; // 힙 크기를 하나 줄이고 마지막 노드 0 초기화\n    \n    for(int i = 1; i*2 <= heapSize;) {\n        \n        // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 끝\n        if(maxHeap[i] > maxHeap[i*2] && maxHeap[i] > maxHeap[i*2+1]) {\n            break;\n        }\n        \n        // 왼쪽 노드가 더 큰 경우, swap\n        else if (maxHeap[i*2] > maxHeap[i*2+1]) {\n            swap(i, i*2);\n            i = i*2;\n        }\n        \n        // 오른쪽 노드가 더 큰 경우\n        else {\n            swap(i, i*2+1);\n            i = i*2+1;\n        }\n    }\n    \n    return item;\n    \n}\n```\n\n<br>\n\n<br>\n\n**[참고 자료]** [링크](<https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html>)', '2022-06-07', '20');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# Tree\n\n<br>\n\n```\nNode와 Edge로 이루어진 자료구조\nTree의 특성을 이해하자\n```\n\n<br>\n\n<img src=\"https://www.geeksforgeeks.org/wp-content/uploads/binary-tree-to-DLL.png\">\n\n<br>\n\n트리는 값을 가진 `노드(Node)`와 이 노드들을 연결해주는 `간선(Edge)`으로 이루어져있다.\n\n그림 상 데이터 1을 가진 노드가 `루트(Root) 노드`다.\n\n모든 노드들은 0개 이상의 자식(Child) 노드를 갖고 있으며 보통 부모-자식 관계로 부른다.\n\n<br>\n\n아래처럼 가족 관계도를 그릴 때 트리 형식으로 나타내는 경우도 많이 봤을 것이다. 자료구조의 트리도 이 방식을 그대로 구현한 것이다.\n\n<img src=\"https://post-phinf.pstatic.net/MjAxOTA4MjZfMTg1/MDAxNTY2Nzc0Mzk2OTMw.k2EDmhB2y4O1MVrL-XqOXibXkSOBtGX8r86emCgUk9Eg.8C_5nfeIvIDSiLO8FL-i4e28h-8DmbQRS4r2CqSJ6TUg.JPEG/2216_nephew.jpg?type=w1200\" width=\"500\">\n\n<br>\n\n트리는 몇 가지 특징이 있다.\n\n- 트리에는 사이클이 존재할 수 없다. (만약 사이클이 만들어진다면, 그것은 트리가 아니고 그래프다)\n- 모든 노드는 자료형으로 표현이 가능하다.\n- 루트에서 한 노드로 가는 경로는 유일한 경로 뿐이다.\n- 노드의 개수가 N개면, 간선은 N-1개를 가진다.\n\n<br>\n\n가장 중요한 것은, `그래프`와 `트리`의 차이가 무엇인가인데, 이는 사이클의 유무로 설명할 수 있다.\n\n<br>\n\n###  트리 순회 방식\n\n트리를 순회하는 방식은 총 4가지가 있다. 위의 그림을 예시로 진행해보자\n\n<br>\n\n<img src=\"https://www.geeksforgeeks.org/wp-content/uploads/binary-tree-to-DLL.png\">\n\n<br>\n\n1. #### 전위 순회(pre-order)\n\n   각 루트(Root)를 순차적으로 먼저 방문하는 방식이다. \n\n   (Root → 왼쪽 자식 → 오른쪽 자식)\n\n   > 1 → 2 → 4 → 8 → 9 → 5 → 10 → 11 → 3 → 6 → 13 → 7 → 14\n\n   <br>\n\n2. #### 중위 순회(in-order)\n\n   왼쪽 하위 트리를 방문 후 루트(Root)를 방문하는 방식이다. \n\n   (왼쪽 자식 → Root → 오른쪽 자식)\n\n   > 8 → 4 → 9 → 2 → 10 → 5 → 11 → 1 → 6 → 13 → 3 →14 → 7\n\n   <br>\n\n3. #### 후위 순회(post-order)\n\n   왼쪽 하위 트리부터 하위를 모두 방문 후 루트(Root)를 방문하는 방식이다.\n\n   (왼쪽 자식 → 오른쪽 자식 → Root)\n\n   > 8 → 9 → 4 → 10 → 11 → 5 → 2 → 13 → 6 → 14 → 7 → 3 → 1\n\n   <br>\n\n4. #### 레벨 순회(level-order)\n\n   루트(Root)부터 계층 별로 방문하는 방식이다.\n\n   > 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10 → 11 → 13 → 14\n\n<br>\n\n<br>\n\n### Code\n\n```java\npublic class Tree<T> {\n    private Node<T> root;\n\n    public Tree(T rootData) {\n        root = new Node<T>();\n        root.data = rootData;\n        root.children = new ArrayList<Node<T>>();\n    }\n\n    public static class Node<T> {\n        private T data;\n        private Node<T> parent;\n        private List<Node<T>> children;\n    }\n}\n```\n\n<br>\n\n<br>\n\n#### [참고 자료]\n\n- [링크](https://www.geeksforgeeks.org/binary-tree-data-structure/)', '2022-06-07', '21');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## [자료구조] 이진탐색트리 (Binary Search Tree)\n\n<br>\n\n***이진탐색트리의 목적은?***\n\n> 이진탐색 + 연결리스트\n\n이진탐색 : **탐색에 소요되는 시간복잡도는 O(logN)**, but 삽입,삭제가 불가능\n\n연결리스트 : **삽입, 삭제의 시간복잡도는 O(1)**, but 탐색하는 시간복잡도가 O(N)\n\n이 두가지를 합하여 장점을 모두 얻는 것이 **\'이진탐색트리\'**\n\n즉, 효율적인 탐색 능력을 가지고, 자료의 삽입 삭제도 가능하게 만들자\n\n<br>\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fk074C%2FbtqwZZvI1D3%2FeVUanrpKdIRKnZpkKiQMe0%2Fimg.png\">\n\n<br>\n\n#### 특징\n\n- 각 노드의 자식이 2개 이하\n- 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큼\n- 중복된 노드가 없어야 함\n\n***중복이 없어야 하는 이유는?***\n\n검색 목적 자료구조인데, 굳이 중복이 많은 경우에 트리를 사용하여 검색 속도를 느리게 할 필요가 없음. (트리에 삽입하는 것보다, 노드에 count 값을 가지게 하여 처리하는 것이 훨씬 효율적)\n\n<br>\n\n이진탐색트리의 순회는 **\'중위순회(inorder)\' 방식 (왼쪽 - 루트 - 오른쪽)**\n\n중위 순회로 **정렬된 순서**를 읽을 수 있음\n\n<br>\n\n#### BST 핵심연산\n\n- 검색\n- 삽입\n- 삭제\n- 트리 생성\n- 트리 삭제\n\n<br>\n\n#### 시간 복잡도\n\n- 균등 트리 : 노드 개수가 N개일 때 O(logN)\n- 편향 트리 : 노드 개수가 N개일 때 O(N)\n\n> 삽입, 검색, 삭제 시간복잡도는 **트리의 Depth**에 비례\n\n<br>\n\n#### 삭제의 3가지 Case\n\n1) 자식이 없는 leaf 노드일 때 → 그냥 삭제\n\n2) 자식이 1개인 노드일 때 → 지워진 노드에 자식을 올리기\n\n3) 자식이 2개인 노드일 때 → 오른쪽 자식 노드에서 가장 작은 값 or 왼쪽 자식 노드에서 가장 큰 값 올리기\n\n<br>\n\n편향된 트리(정렬된 상태 값을 트리로 만들면 한쪽으로만 뻗음)는 시간복잡도가 O(N)이므로 트리를 사용할 이유가 사라짐 → 이를 바로 잡도록 도와주는 개선된 트리가 AVL Tree, RedBlack Tree\n\n<br>\n\n[소스 코드(java)](<https://github.com/kim6394/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/code/binarySearchTree.java>)', '2022-06-07', '22');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 해시(Hash)\n\n데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것\n\n해시 함수를 구현하여 데이터 값을 해시 값으로 매핑한다.\n\n<br>\n\n```\nLee → 해싱함수 → 5\nKim → 해싱함수 → 3\nPark → 해싱함수 → 2\n...\nChun → 해싱함수 → 5 // Lee와 해싱값 충돌\n```\n\n결국 데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌나는 현상이 발생함 **\'collision\' 현상**\n\n***그래도 해시 테이블을 쓰는 이유는?***\n\n> 적은 자원으로 많은 데이터를 효율적으로 관리하기 위해\n>\n> 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해짐!\n\n- 언제나 동일한 해시값 리턴, index를 알면 빠른 데이터 검색이 가능해짐\n- 해시테이블의 시간복잡도 O(1) - (이진탐색트리는 O(logN))\n\n<br>\n\n##### 충돌 문제 해결\n\n1. **체이닝** : 연결리스트로 노드를 계속 추가해나가는 방식 \n   (제한 없이 계속 연결 가능, but 메모리 문제)\n\n2. **Open Addressing** : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용 (해당 키 값에 저장되어있으면 다음 주소에 저장)\n\n3. **선형 탐사** : 정해진 고정 폭으로 옮겨 해시값의 중복을 피함\n4. **제곱 탐사** : 정해진 고정 폭을 제곱수로 옮겨 해시값의 중복을 피함 \n\n<br>\n\n<br>\n\n참고자료 : [링크](<https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/>)', '2022-06-07', '23');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 트라이(Trie)\n\n> 문자열에서 검색을 빠르게 도와주는 자료구조\n\n```\n정수형에서 이진탐색트리를 이용하면 시간복잡도 O(logN)\n하지만 문자열에서 적용했을 때, 문자열 최대 길이가 M이면 O(M*logN)이 된다.\n\n트라이를 활용하면? → O(M)으로 문자열 검색이 가능함!\n```\n\n<br>\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/24354E335833A7CF17\">\n\n> 예시 그림에서 주어지는 배열의 총 문자열 개수는 8개인데, 트라이를 활용한 트리에서도 마지막 끝나는 노드마다 \'네모\' 모양으로 구성된 것을 확인하면 총 8개다.\n\n<br>\n\n해당 자료구조를 풀어보기 위해 좋은 문제 : [백준 5052(전화번호 목록)](<https://www.acmicpc.net/problem/5052>)\n\n##### 문제에서 Trie를 java로 구현한 코드\n\n```java\nstatic class Trie {\n    boolean end;\n    boolean pass;\n    Trie[] child;\n\n    Trie() {\n        end = false;\n        pass = false;\n        child = new Trie[10];\n    }\n\n    public boolean insert(String str, int idx) {\n\n        //끝나는 단어 있으면 false 종료\n        if(end) return false;\n\n        //idx가 str만큼 왔을때\n        if(idx == str.length()) {\n            end = true;\n            if(pass) return false; // 더 지나가는 단어 있으면 false 종료\n            else return true;\n        }\n        //아직 안왔을 때\n        else {\n            int next = str.charAt(idx) - \'0\';\n            if(child[next] == null) {\n                child[next] = new Trie();\n                pass = true;\n            }\n            return child[next].insert(str, idx+1);\n        }\n\n    }\n}\n```\n', '2022-06-07', '24');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## B Tree & B+ Tree\n\n<br>\n\n> **이진 트리**는 하나의 부모가 두 개의 자식밖에 가지질 못하고, 균형이 맞지 않으면 검색 효율이 선형검색 급으로 떨어진다. 하지만 이진 트리 구조의 간결함과 균형만 맞다면 검색, 삽입, 삭제 모두 O(logN)의 성능을 보이는 장점이 있기 때문에 계속 개선시키기 위한 노력이 이루어지고 있다.\n\n<br>\n\n#### B Tree\n\n---\n\n데이터베이스, 파일 시스템에서 널리 사용되는 트리 자료구조의 일종이다.\n\n이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 것이 B-Tree\n\n<br>\n\n자식 수에 대한 일반화를 진행하면서, 하나의 레벨에 더 저장되는 것 뿐만 아니라 트리의 균형을 자동으로 맞춰주는 로직까지 갖추었다. 단순하고 효율적이며, 레벨로만 따지면 완전히 균형을 맞춘 트리다.\n\n```\n대량의 데이터를 처리해야 할 때, 검색 구조의 경우 하나의 노드에 많은 데이터를 가질 수 있다는 점은 상당히 큰 장점이다.\n\n대량의 데이터는 메모리보다 블럭 단위로 입출력하는 하드디스크 or SSD에 저장해야하기 때문!\n\nex) 한 블럭이 1024 바이트면, 2바이트를 읽으나 1024바이트를 읽으나 똑같은 입출력 비용 발생. 따라서 하나의 노드를 모두 1024바이트로 꽉 채워서 조절할 수 있으면 입출력에 있어서 효율적인 구성을 갖출 수 있다.\n\n→ B-Tree는 이러한 장점을 토대로 많은 데이터베이스 시스템의 인덱스 저장 방법으로 애용하고 있음\n```\n\n<br>\n\n##### 규칙\n\n- 노드의 자료수가 N이면, 자식 수는 N+1이어야 함\n- 각 노드의 자료는 정렬된 상태여야함\n- 루트 노드는 적어도 2개 이상의 자식을 가져야함\n- 루트 노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가지고 있어야함\n- 외부 노드로 가는 경로의 길이는 모두 같음.\n- 입력 자료는 중복 될 수 없음\n\n<br>\n\n<br>\n\n#### B+ Tree\n\n---\n\n데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가로 있음\n\n(기존의 B-Tree와 데이터의 연결리스트로 구현된 색인구조)\n\n<br>\n\nB-Tree의 변형 구조로, index 부분과 leaf 노드로 구성된 순차 데이터 부분으로 이루어진다. 인덱스 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용함.\n\n<br>\n\n##### 장점\n\n> 블럭 사이즈를 더 많이 이용할 수 있음 (key 값에 대한 하드디스크 액세스 주소가 없기 때문)\n>\n> leaf 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리함\n\n##### 단점\n\n> B-tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+tree는 무조건 leaf 노드까지 내려가봐야 함\n\n<br>\n\n<br>\n\n<br>\n\n##### B-Tree & B+ Tree\n\n> B-tree는 각 노드에 데이터가 저장됨\n>\n> B+tree는 index 노드와 leaf 노드로 분리되어 저장됨\n>\n> (또한, leaf 노드는 서로 연결되어 있어서 임의접근이나 순차접근 모두 성능이 우수함)\n\n<br>\n\nB-tree는 각 노드에서 key와 data 모두 들어갈 수 있고, data는 disk block으로 포인터가 될 수 있음\n\nB+tree는 각 노드에서 key만 들어감. 따라서 data는 모두 leaf 노드에만 존재\n\nB+tree는 add와 delete가 모두 leaf 노드에서만 이루어짐\n\n<br>\n\n**참고자료** : [링크](<https://wangin9.tistory.com/entry/B-tree-B-tree>)', '2022-06-07', '25');
insert into cscontent (cs_content, cs_regdate, cs_code) values('<img src=https://user-images.githubusercontent.com/88614978/172389443-0eab75a0-8263-4e9b-be58-b4424515ebd0.png width=\"500\">\n<img src=https://user-images.githubusercontent.com/88614978/172389448-78507d9f-7258-4246-afb9-49e81f623306.png width=\"500\">\n<img src=https://user-images.githubusercontent.com/88614978/172389453-00bdec4b-10c2-407a-8c58-39e44a5f4656.png width=\"500\">', '2022-06-07', '26');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 컴퓨터의 구성\n\n컴퓨터가 가지는 구성에 대해 알아보자\n\n<br>\n\n컴퓨터 시스템은 크게 하드웨어와 소프트웨어로 나누어진다.\n\n**하드웨어** : 컴퓨터를 구성하는 기계적 장치\n\n**소프트웨어** : 하드웨어의 동작을 지시하고 제어하는 명령어 집합\n\n<br>\n\n#### 하드웨어\n\n---\n\n- 중앙처리장치(CPU)\n- 기억장치 : RAM, HDD\n- 입출력 장치 : 마우스, 프린터\n\n#### 소프트웨어\n\n---\n\n- 시스템 소프트웨어 : 운영체제, 컴파일러\n- 응용 소프트웨어 : 워드프로세서, 스프레드시트\n\n<br>\n\n먼저 하드웨어부터 살펴보자\n\n<img src=\"data:image/png;base64,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\">\n\n\n\n하드웨어는 중앙처리장치(CPU), 기억장치, 입출력장치로 구성되어 있다.\n\n이들은 시스템 버스로 연결되어 있으며, 시스템 버스는 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할을 한다.\n\n<br>\n\n##### 중앙처리장치(CPU)\n\n인간으로 따지면 두뇌에 해당하는 부분\n\n주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어함\n중앙처리장치는 비교와 연산을 담당하는 <strong>산술논리연산장치(ALU)</strong>와 명령어의 해석과 실행을 담당하는 **제어장치**, 속도가 빠른 데이터 기억장소인 **레지스터**로 구성되어있음\n\n개인용 컴퓨터와 같은 소형 컴퓨터에서는 CPU를 마이크로프로세서라고도 부름\n\n<br>\n\n##### 기억장치\n\n프로그램, 데이터, 연산의 중간 결과를 저장하는 장치\n\n주기억장치와 보조기억장치로 나누어지며, RAM과 ROM도 이곳에 해당함. 실행중인 프로그램과 같은 프로그램에 필요한 데이터를 일시적으로 저장한다.\n\n보조기억장치는 하드디스크 등을 말하며, 주기억장치에 비해 속도는 느리지만 많은 자료를 영구적으로 보관할 수 있는 장점이 있다.\n\n<br>\n\n##### 입출력장치\n\n입력과 출력 장치로 나누어짐. \n\n입력 장치는 컴퓨터 내부로 자료를 입력하는 장치 (키보드, 마우스 등)\n\n출력 장치는 컴퓨터에서 외부로 표현하는 장치 (프린터, 모니터, 스피커 등)\n\n<br>\n\n<br>\n\n#### 시스템 버스\n\n> 하드웨어 구성 요소를 물리적으로 연결하는 선\n\n각 구성요소가 다른 구성요소로 데이터를 보낼 수 있도록 통로가 되어줌\n\n용도에 따라 데이터 버스, 주소 버스, 제어 버스로 나누어짐\n\n<br>\n\n##### 데이터 버스\n\n중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로\n\n기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나, 중앙처리장치의 연산 결과를 기억장치와 입출력장치로 보내는 \'양방향\' 버스임\n\n##### 주소 버스\n\n데이터를 정확히 실어나르기 위해서는 기억장치 \'주소\'를 정해주어야 함.\n\n주소버스는 중앙처리장치가 주기억장치나 입출력장치로 기억장치 주소를 전달하는 통로이기 때문에 \'단방향\' 버스임\n\n##### 제어 버스\n\n주소 버스와 데이터 버스는 모든 장치에 공유되기 때문에 이를 제어할 수단이 필요함\n\n제어 버스는 중앙처리장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로임\n\n제어 신호 종류 : 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋 등\n\n제어 버스는 읽기 동작과 쓰기 동작을 모두 수행하기 때문에 \'양방향\' 버스임\n\n<br>\n\n컴퓨터는 기본적으로 **읽고 처리한 뒤 저장**하는 과정으로 이루어짐\n\n(READ → PROCESS → WRITE)\n\n이 과정을 진행하면서 끊임없이 주기억장치(RAM)과 소통한다. 이때 운영체제가 64bit라면, CPU는 RAM으로부터 데이터를 한번에 64비트씩 읽어온다.\n\n<br>', '2022-06-07', '27');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 중앙처리장치(CPU) 작동 원리\n\n\n\nCPU는 컴퓨터에서 가장 핵심적인 역할을 수행하는 부분. \'인간의 두뇌\'에 해당\n\n크게 연산장치, 제어장치, 레지스터 3가지로 구성됨\n\n\n\n- ##### 연산 장치\n\n  > 산술연산과 논리연산 수행 (따라서 산술논리연산장치라고도 불림)\n  >\n  > 연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보냄\n\n- ##### 제어 장치\n\n  > 명령어를 순서대로 실행할 수 있도록 제어하는 장치\n  >\n  > 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄\n  >\n  > 또한 이들 장치가 보낸 신호를 받아, 다음에 수행할 동작을 결정함\n\n- ##### 레지스터\n\n  > 고속 기억장치임\n  >\n  > 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장\n  >\n  > 용도에 따라 범용 레지스터와 특수목적 레지스터로 구분됨\n  >\n  > 중앙처리장치 종류에 따라 사용할 수 있는 레지스터 개수와 크기가 다름\n  >\n  > - 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장\n  > - 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터\n\n\n\n#### 특수 목적 레지스터 중 중요한 것들\n\n- MAR(메모리 주소 레지스터) : 읽기와 쓰기 연산을 수행할 주기억장치 주소 저장\n- PC(프로그램 카운터) : 다음에 수행할 명령어 주소 저장\n- IR(명령어 레지스터) : 현재 실행 중인 명령어 저장\n- MBR(메모리 버퍼 레지스터) : 주기억장치에서 읽어온 데이터 or 저장할 데이터 임시 저장\n- AC(누산기) : 연산 결과 임시 저장\n\n\n\n#### CPU의 동작 과정\n\n1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴\n2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장\n3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄\n4. 제어장치는 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어\n\n\n\n##### 명령어 세트란?\n\nCPU가 실행할 명령어의 집합\n\n> 연산 코드(Operation Code) + 피연산자(Operand)로 이루어짐\n>\n> 연산 코드 : 실행할 연산\n>\n> 피연산자 : 필요한 데이터 or 저장 위치\n\n\n\n연산 코드는 연산, 제어, 데이터 전달, 입출력 기능을 가짐\n\n피연산자는 주소, 숫자/문자, 논리 데이터 등을 저장\n\n\n\nCPU는 프로그램 실행하기 위해 주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정을 반복함\n\nCPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동을 \'명령어 사이클\'이라고 말함\n\n명령어 사이클은 인출/실행/간접/인터럽트 사이클로 나누어짐\n\n주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, 실행 사이클에서는 명령어를 실행함. 하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 인출 사이클 시작\n\n\n\n##### 인출 사이클과 실행 사이클에 의한 명령어 처리 과정\n\n> 인출 사이클에서 가장 중요한 부분은 PC(프로그램 카운터) 값 증가\n\n- PC에 저장된 주소를 MAR로 전달\n\n- 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출\n- 인출한 명령어를 MBR에 저장\n- 다음 명령어를 인출하기 위해 PC 값 증가시킴\n- 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달\n\n```\nT0 : MAR ← PC\nT1 : MBR ← M[MAR], PC ← PC+1\nT2 : IR ← MBR\n```\n\n여기까지는 인출하기까지의 과정\n\n\n\n##### 인출한 이후, 명령어를 실행하는 과정\n\n> ADD addr 명령어 연산\n\n```\nT0 : MAR ← IR(Addr)\nT1 : MBR ← M[MAR]\nT2 : AC ← AC + MBR\n```\n\n이미 인출이 진행되고 명령어만 실행하면 되기 때문에 PC를 증가할 필요x\n\nIR에 MBR의 값이 이미 저장된 상태를 의미함\n\n따라서 AC에 MBR을 더해주기만 하면 됨\n', '2022-06-07', '28');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 고정 소수점 & 부동 소수점\n\n<br>\n\n컴퓨터에서 실수를 표현하는 방법은 `고정 소수점`과 `부동 소수점` 두가지 방식이 존재한다.\n\n<br>\n\n1. #### 고정 소수점(Fixed Point)\n\n   > 소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식 (정수 + 소수)\n   >\n   > ```\n   > -3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소 필요함\n   > ```\n\n   ![고정 소수점 방식](http://tcpschool.com/lectures/img_c_fixed_point.png)\n\n   **장점** : 실수를 정수부와 소수부로 표현하여 단순하다.\n\n   **단점** : 표현의 범위가 너무 적어서 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)\n\n   <br>\n\n   <br>\n\n2. #### 부동 소수점(Floating Point)\n\n   > 실수를 가수부 + 지수부로 표현한다.\n   >\n   > - 가수 : 실수의 실제값 표현\n   > - 지수 : 크기를 표현함. 가수의 어디쯤에 소수점이 있는지 나타냄\n\n   **지수의 값에 따라 소수점이 움직이는 방식**을 활용한 실수 표현 방법이다.\n\n   즉, 소수점의 위치가 고정되어 있지 않는다.\n\n   ![32비트 부동 소수점](http://tcpschool.com/lectures/img_c_floating_point_32.png)\n\n   **장점** : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용 중)\n\n   **단점** :  오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함)', '2022-06-07', '29');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 패리티 비트 & 해밍 코드\n\n<br>\n\n### 패리티 비트\n\n> 정보 전달 과정에서 오류가 생겼는 지 검사하기 위해 추가하는 비트를 말한다.\n>\n> 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송한다.\n\n<br>\n\n**종류** : 짝수, 홀수\n\n전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정하는 것\n\n<br>\n\n***짝수 패리티일 때 7비트 데이터가 1010001라면?***\n\n> 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함\n>\n> 답 : 11010001 (맨앞이 패리티비트)\n\n<br>\n\n<br>\n\n### 해밍 코드\n\n> 데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류정정 코드를 말한다.\n>\n> 패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다.\n> (패리티 비트는 오류를 검출하기만 할 뿐 수정하지는 않기 때문에 해밍 코드를 활용)\n\n<br>\n\n##### 방법\n\n2의 n승 번째 자리인 1,2,4번째 자릿수가 패리티 비트라는 것으로 부터 시작한다. 이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지, 홀수인지 기준으로 판별한다.\n\n<br>\n\n***짝수 패리티의 해밍 코드가 0011011일때 오류가 수정된 코드는?***\n\n1) 1, 3, 5, 7번째 비트 확인 : 0101로 짝수이므로 \'0\'\n\n2) 2, 3, 6, 7번째 비트 확인 : 0111로 홀수이므로 \'1\'\n\n3) 4, 5, 6, 7번째 비트 확인 : 1011로 홀수이므로 \'1\'\n\n<br>\n\n역순으로 패리티비트 \'110\'을 도출했다. 10진법으로 바꾸면 \'6\'으로, 6번째 비트를 수정하면 된다.\n\n따라서 **정답은 00110\'0\'1**이다.', '2022-06-07', '30');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## ARM 프로세서\n\n<br>\n\n*프로세서란?*\n\n> 메모리에 저장된 명령어들을 실행하는 유한 상태 오토마톤\n\n<br>\n\n##### ARM : Advanced RISC Machine\n\n즉, `진보된 RISC 기기`의 약자로 ARM의 핵심은 RISC이다.\n\nRISC : Reduced Instruction Set Computing (감소된 명령 집합 컴퓨팅)\n\n`단순한 명령 집합을 가진 프로세서`가 `복잡한 명령 집합을 가진 프로세서`보다 훨씬 더 효율적이지 않을까?로 탄생함\n\n<br>\n\n<br>\n\n#### ARM 구조\n\n---\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/25788C3550CAF8731A\" width=\"500\">\n\n<br>\n\nARM은 칩의 기본 설계 구조만 만들고, 실제 기능 추가와 최적화 부분은 개별 반도체 제조사의 영역으로 맡긴다. 따라서 물리적 설계는 같아도, 명령 집합이 모두 다르기 때문에 서로 다른 칩이 되기도 하는 것이 ARM.\n\n소비자에게는 칩이 논리적 구조인 명령 집합으로 구성되면서, 이런 특성 때문에 물리적 설계 베이스는 같지만 용도에 따라 다양한 제품군을 만날 수 있는 특징이 있다.\n\n아무래도 아키텍처는 논리적인 명령 집합을 물리적으로 표현한 것이므로, 명령어가 많고 복잡해질수록 실제 물리적인 칩 구조도 크고 복잡해진다.\n\n하지만, ARM은 RISC 설계 기반으로 \'단순한 명령집합을 가진 프로세서가 복잡한 것보다 효율적\'임을 기반하기 때문에 명령 집합과 구조 자체가 단순하다. 따라서 ARM 기반 프로세서가 더 작고, 효율적이며 상대적으로 느린 것이다.\n\n<br>\n\n단순한 명령 집합은, 적은 수의 트랜지스터만 필요하므로 간결한 설계와 더 작은 크기를 가능케 한다. 반도체 기본 부품인 트랜지스터는 전원을 소비해 다이의 크기를 증가시키기 때문에 스마트폰이나 태블릿PC를 위한 프로세서에는 가능한 적은 트랜지스터를 가진 것이 이상적이다.\n\n따라서, 명령 집합의 수가 적기 때문에 트랜지스터 수가 적고 이를 통해 크기가 작고 전원 소모가 낮은 ARM CPU가 스마트폰, 태블릿PC와 같은 모바일 기기에 많이 사용되고 있다.\n\n<br>\n\n<br>\n\n#### ARM의 장점은?\n\n---\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/1970603350CD96BC35\" width=200>\n\n<br>\n\n소비자에 있어 ARM은 \'생태계\'의 하나라고 생각할 수 있다. ARM을 위해 개발된 프로그램은 오직 ARM 프로세서가 탑재된 기기에서만 실행할 수 있다. (즉, x86 CPU 프로세서 기반 프로그램에서는 ARM 기반 기기에서 실행할 수 없음)\n\n따라서 ARM에서 실행되던 프로그램을 x86 프로세서에서 실행되도록 하려면 (혹은 그 반대로) 프로그램에 수정이 가해져야만 한다.\n\n <br>\n\n하지만, 하나의 ARM 기기에 동작하는 OS는 다른 ARM 기반 기기에서도 잘 동작한다. 이러한 장점 덕분에 수많은 버전의 안드로이드가 탄생하고 있으며 또한 HP나 블랙베리의 태블릿에도 안드로이드가 탑재될 수 있는 가능성이 생기게 된 것이다.\n\n(하지만 애플사는 iOS 소스코드를 공개하지 않고 있기 때문에 애플 기기는 불가능하다)\n\nARM을 만드는 기업들은 통해 전력 소모를 줄이고 성능을 높이기 위해 설계를 개선하며 노력하고 있다.\n\n<br>\n\n<br>\n\n<br>\n\n##### [참고 자료]\n\n- [링크](https://sergeswin.com/611)', '2022-06-07', '31');
insert into cscontent (cs_content, cs_regdate, cs_code) values('### [DB] Key\n\n---\n\n> Key란? : 검색, 정렬시 Tuple을 구분할 수 있는 기준이 되는 Attribute.\n\n<br>\n\n#### 1. Candidate Key (후보키)\n\n> Tuple을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합. (기본키로 사용할 수 있는 속성들)\n\n2가지 조건 만족\n\n* 유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음\n* 최소성 : 꼭 필요한 속성으로만 구성\n\n<br>\n\n#### 2. Primary Key (기본키)\n\n> 후보키 중 선택한 Main Key\n\n특징 \n\n* Null 값을 가질 수 없음\n* 동일한 값이 중복될 수 없음\n\n<br>\n\n#### 3. Alternate Key (대체키)\n\n> 후보키 중 기본키를 제외한 나머지 키 = 보조키\n\n<br>\n\n#### 4. Super Key (슈퍼키)\n\n> 유일성은 만족하지만, 최소성은 만족하지 못하는 키\n\n<br>\n\n#### 5. Foreign Key (외래키)\n\n> 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합\n\n<br>', '2022-06-07', '32');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## [Database SQL] JOIN\n\n##### 조인이란?\n\n> 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법\n\n테이블을 연결하려면, 적어도 하나의 칼럼을 서로 공유하고 있어야 하므로 이를 이용하여 데이터 검색에 활용한다.\n\n<br>\n\n#### JOIN 종류\n\n---\n\n- INNER JOIN\n- LEFT OUTER JOIN\n- RIGHT OUTER JOIN\n- FULL OUTER JOIN\n- CROSS JOIN\n- SELF JOIN\n\n<br>\n\n<br>\n\n- #### INNER JOIN\n\n  <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F99799F3E5A8148D7036659\">\n\n  교집합으로, 기준 테이블과 join 테이블의 중복된 값을 보여준다.\n\n  ```sql\n  SELECT\n  A.NAME, B.AGE\n  FROM EX_TABLE A\n  INNER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP\n  ```\n\n  <br>\n\n- #### LEFT OUTER JOIN\n\n  <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F997E7F415A81490507F027\">\n\n  기준테이블값과 조인테이블과 중복된 값을 보여준다.\n\n  왼쪽테이블 기준으로 JOIN을 한다고 생각하면 편하다.\n\n  ```SQL\n  SELECT\n  A.NAME, B.AGE\n  FROM EX_TABLE A\n  LEFT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP\n  ```\n\n  <br>\n\n- #### RIGHT OUTER JOIN\n\n  <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F9984CE355A8149180ABD1D\">\n\n  LEFT OUTER JOIN과는 반대로 오른쪽 테이블 기준으로 JOIN하는 것이다.\n\n  ```SQL\n  SELECT\n  A.NAME, B.AGE\n  FROM EX_TABLE A\n  RIGHT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP\n  ```\n\n  <br>\n\n- #### FULL OUTER JOIN\n\n  <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F99195F345A8149391BE0C3\">\n\n  합집합을 말한다. A와 B 테이블의 모든 데이터가 검색된다.\n\n  ```sql\n  SELECT\n  A.NAME, B.AGE\n  FROM EX_TABLE A\n  FULL OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP\n  ```\n\n  <br>\n\n- #### CROSS JOIN\n\n  <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F993F4E445A8A2D281AC66B\">\n\n  모든 경우의 수를 전부 표현해주는 방식이다.\n\n  A가 3개, B가 4개면 총 3*4 = 12개의 데이터가 검색된다.\n\n  ```sql\n  SELECT\n  A.NAME, B.AGE\n  FROM EX_TABLE A\n  CROSS JOIN JOIN_TABLE B\n  ```\n\n  <br>\n\n- #### SELF JOIN\n\n  <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F99341D335A8A363D0614E8\">\n\n  자기자신과 자기자신을 조인하는 것이다.\n\n  하나의 테이블을 여러번 복사해서 조인한다고 생각하면 편하다.\n\n  자신이 갖고 있는 칼럼을 다양하게 변형시켜 활용할 때 자주 사용한다.\n\n  ``` sql\n  SELECT\n  A.NAME, B.AGE\n  FROM EX_TABLE A, EX_TABLE B\n  ```\n\n  \n\n<br>\n\n<br>\n\n##### [참고]\n\n[링크](<https://coding-factory.tistory.com/87>)', '2022-06-07', '33');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## SQL Injection\n\n> 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법\n\n<br>\n\n#### 공격 방법\n\n##### 1) 인증 우회\n\n보통 로그인을 할 때, 아이디와 비밀번호를 input 창에 입력하게 된다. 쉽게 이해하기 위해 가벼운 예를 들어보자. 아이디가 abc, 비밀번호가 만약 1234일 때 쿼리는 아래와 같은 방식으로 전송될 것이다.\n\n```\nSELECT * FROM USER WHERE ID = \"abc\" AND PASSWORD = \"1234\";\n```\n\nSQL Injection으로 공격할 때, input 창에 비밀번호를 입력함과 동시에 다른 쿼리문을 함께 입력하는 것이다.\n\n```\n1234; DELETE * USER FROM ID = \"1\";\n```\n\n보안이 완벽하지 않은 경우, 이처럼 비밀번호가 아이디와 일치해서 True가 되고 뒤에 작성한 DELETE 문도 데이터베이스에 영향을 줄 수도 있게 되는 치명적인 상황이다.\n\n이 밖에도 기본 쿼리문의 WHERE 절에 OR문을 추가하여 `\'1\' = \'1\'`과 같은 true문을 작성하여 무조건 적용되도록 수정한 뒤 DB를 마음대로 조작할 수도 있다. \n\n<br>\n\n##### 2) 데이터 노출\n\n시스템에서 발생하는 에러 메시지를 이용해 공격하는 방법이다. 보통 에러는 개발자가 버그를 수정하는 면에서 도움을 받을 수 있는 존재다. 해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.\n\n즉 예를 들면, 해커는 **GET 방식으로 동작하는 URL 쿼리 스트링을 추가하여 에러를 발생**시킨다. 이에 해당하는 오류가 발생하면, 이를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고 해킹에 활용한다.\n\n<br>\n\n<br>\n\n#### 방어 방법\n\n##### 1) input 값을 받을 때, 특수문자 여부 검사하기\n\n> 로그인 전, 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다.\n\n##### 2) SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기\n\n> view를 활용하여 원본 데이터베이스 테이블에는 접근 권한을 높인다. 일반 사용자는 view로만 접근하여 에러를 볼 수 없도록 만든다.\n\n##### 3) preparestatement 사용하기\n\n> preparestatement를 사용하면, 특수문자를 자동으로 escaping 해준다. (statement와는 다르게 쿼리문에서 전달인자 값을 `?`로 받는 것) 이를 활용해 서버 측에서 필터링 과정을 통해서 공격을 방어한다.\n', '2022-06-07', '34');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## SQL과 NOSQL의 차이\n\n<br>\n\n웹 앱을 개발할 때, 데이터베이스를 선택할 때 고민하게 된다.\n\n<br>\n\n```\nMySQL과 같은 SQL을 사용할까? 아니면 MongoDB와 같은 NoSQL을 사용할까?\n```\n\n<br>\n\n보통 Spring에서 개발할 때는 MySQL을, Node.js에서는 MongoDB를 주로 사용했을 것이다.\n\n하지만 그냥 단순히 프레임워크에 따라 결정하는 것이 아니다. 프로젝트를 진행하기에 앞서 적합한 데이터베이스를 택해야 한다. 차이점을 알아보자\n\n<br>\n\n#### SQL (관계형 DB)\n\n---\n\n SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있음\n\n관계형 데이터베이스에는 핵심적인 두 가지 특징이 있다.\n\n- 데이터는 **정해진 데이터 스키마에 따라 테이블에 저장**된다.\n- 데이터는 **관계를 통해 여러 테이블에 분산**된다.\n\n<br>\n\n데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조가 있다.\n해당 구조는 필드의 이름과 데이터 유형으로 정의된다.\n\n따라서 **스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다.** 즉, 스키마를 수정하지 않는 이상은 정해진 구조에 맞는 레코드만 추가가 가능한 것이 관계형 데이터베이스의 특징 중 하나다.\n\n<br>\n\n또한, 데이터의 중복을 피하기 위해 \'관계\'를 이용한다.\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/994D09355C937ECD2D\">\n\n하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에 다른 테이블에서 부정확한 데이터를 다룰 위험이 없어지는 장점이 있다.\n\n<br>\n\n<br>\n\n#### NoSQL (비관계형 DB)\n\n---\n\n말그대로 관계형 DB의 반대다.\n\n**스키마도 없고, 관계도 없다!**\n\n<br>\n\nNoSQL에서는 레코드를 문서(documents)라고 부른다.\n\n여기서 SQL과 핵심적인 차이가 있는데, SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능했다. 하지만 NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.\n\n<br>\n\n문서(documents)는 Json과 비슷한 형태로 가지고 있다. 관계형 데이터베이스처럼 여러 테이블에 나누어담지 않고, 관련 데이터를 동일한 \'컬렉션\'에 넣는다.\n\n따라서 위 사진에 SQL에서 진행한 Orders, Users, Products 테이블로 나눈 것을 NoSQL에서는 Orders에 한꺼번에 포함해서 저장하게 된다.\n\n따라서 여러 테이블에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다. (NoSQL에는 조인이라는 개념이 존재하지 않음)\n\n<br>\n\n그러면 조인하고 싶을 때 NoSQL은 어떻게 할까? \n\n> 컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출하도록 한다.\n\n하지만 이러면 데이터가 중복되어 서로 영향을 줄 위험이 있다. 따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.\n\n<br>\n\n<br>\n\n#### 확장 개념\n\n두 데이터베이스를 비교할 때 중요한 Scaling 개념도 존재한다.\n\n데이터베이스 서버의 확장성은 \'수직적\' 확장과 \'수평적\' 확장으로 나누어진다.\n\n- 수직적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)\n- 수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)\n\n<br>\n\n데이터 저장 방식으로 인해 SQL 데이터베이스는 일반적으로 수직적 확장만 지원함\n\n> 수평적 확장은 NoSQL 데이터베이스에서만 가능\n\n<br>\n\n<br>\n\n#### 그럼 둘 중에 뭘 선택?\n\n정답은 없다. 둘다 훌륭한 솔루션이고 어떤 데이터를 다루느냐에 따라 선택을 고려해야한다.\n\n<br>\n\n##### SQL 장점\n\n- 명확하게 정의된 스키마, 데이터 무결성 보장\n- 관계는 각 데이터를 중복없이 한번만 저장\n\n##### SQL 단점\n\n- 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)\n- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음\n- 대체로 수직적 확장만 가능함\n\n<br>\n\n##### NoSQL 장점\n\n- 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능\n- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐\n- 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능\n\n##### NoSQL 단점\n\n- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음\n- 데이터 중복을 계속 업데이트 해야 함\n- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함\n  (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)\n\n<br>\n\n<br>\n\n#### SQL 데이터베이스 사용이 더 좋을 때\n\n- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우\n\n  > NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적\n\n- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우\n\n<br>\n\n#### NoSQL 데이터베이스 사용이 더 좋을 때\n\n- 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우\n- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우\n- 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)\n\n<br>\n\n<br>\n\n하나의 제시 방법이지 완전한 정답이 정해져 있는 것은 아니다.\n\nSQL을 선택해서 복잡한 JOIN문을 만들지 않도록 설계하여 단점을 없앨 수도 있고\n\nNoSQL을 선택해서 중복 데이터를 줄이는 방법으로 설계해서 단점을 없앨 수도 있다.\n', '2022-06-07', '35');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# 정규화(Normalization)\n\n<br>\n\n```\n데이터의 중복을 줄이고, 무결성을 향상시킬 수 있는 정규화에 대해 알아보자\n```\n\n<br>\n\n### Normalization\n\n가장 큰 목표는 테이블 간 **중복된 데이터를 허용하지 않는 것**이다.\n\n중복된 데이터를 만들지 않으면, 무결성을 유지할 수 있고, DB 저장 용량 또한 효율적으로 관리할 수 있다.\n\n<br>\n\n### 목적\n\n- 데이터의 중복을 없애면서 불필요한 데이터를 최소화시킨다.\n- 무결성을 지키고, 이상 현상을 방지한다.\n- 테이블 구성을 논리적이고 직관적으로 할 수 있다.\n- 데이터베이스 구조를 확장에 용이해진다.\n\n<br>\n\n정규화에는 여러가지 단계가 있지만, 대체적으로 1~3단계 정규화까지의 과정을 거친다.\n\n<br>\n\n### 제 1정규화(1NF)\n\n테이블 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분리시키는 것을 말한다.\n\n만족해야 할 조건은 아래와 같다.\n\n- 어떤 릴레이션에 속한 모든 도메인이 원자값만으로 되어 있어야한다.\n- 모든 속성에 반복되는 그룹이 나타나지 않는다.\n- 기본키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야 한다.\n\n<br>\n\n<img src=\"http://dl.dropbox.com/s/9s8vowdzs3t66uw/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-02%2017.50.02.png\">\n\n<br>\n\n현재 테이블은 전화번호를 여러개 가지고 있어 원자값이 아니다. 따라서 1NF에 맞추기 위해서는 아래와 같이 분리할 수 있다.\n\n<br>\n\n<img src=\"http://dl.dropbox.com/s/1rr8ofxuy46i61b/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-02%2018.00.52.png\">\n\n<br>\n\n<br>\n\n### 제 2정규화(2NF)\n\n테이블의 모든 컬럼이 완전 함수적 종속을 만족해야 한다.\n\n조금 쉽게 말하면, 테이블에서 기본키가 복합키(키1, 키2)로 묶여있을 때, 두 키 중 하나의 키만으로 다른 컬럼을 결정지을 수 있으면 안된다.\n\n> 기본키의 부분집합 키가 결정자가 되어선 안된다는 것\n\n<br>\n\n<img src=\"http://dl.dropbox.com/s/c2xfxdanbuiaw1l/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-03%2006.58.17.png\">\n\n<br>\n\n`Manufacture`과 `Model`이 키가 되어 `Model Full Name`을 알 수 있다.\n\n`Manufacturer Country`는 `Manufacturer`로 인해 결정된다. (부분 함수 종속)\n\n따라서, `Model`과 `Manufacturer Country`는 아무런 연관관계가 없는 상황이다.\n\n<br>\n\n결국 완전 함수적 종속을 충족시키지 못하고 있는 테이블이다. 부분 함수 종속을 해결하기 위해 테이블을 아래와 같이 나눠서 2NF를 만족할 수 있다.\n\n<br>\n\n<img src=\"http://dl.dropbox.com/s/x8481598dhnpzeg/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-03%2010.58.15.png\">\n\n<br>\n\n<br>\n\n### 제 3정규화(3NF)\n\n2NF가 진행된 테이블에서 이행적 종속을 없애기 위해 테이블을 분리하는 것이다.\n\n> 이행적 종속 : A → B, B → C면 A → C가 성립된다\n\n아래 두가지 조건을 만족시켜야 한다.\n\n- 릴레이션이 2NF에 만족한다.\n- 기본키가 아닌 속성들은 기본키에 의존한다.\n\n<br>\n\n<img src=\"http://dl.dropbox.com/s/xtfoetv8hg6jn3f/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-03%2012.59.46.png\">\n\n<br>\n\n현재 테이블에서는 `Tournament`와 `Year`이 기본키다.\n\n`Winner`는 이 두 복합키를 통해 결정된다.\n\n하지만 `Winner Date of Birth`는 기본키가 아닌 `Winner`에 의해 결정되고 있다. \n\n따라서 이는 3NF를 위반하고 있으므로 아래와 같이 분리해야 한다.\n\n<br>\n\n<img src=\"http://dl.dropbox.com/s/ks03nkc26nsffin/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-12-04%2014.51.39.png\">\n\n<br>\n\n<br>\n\n#### [참고 사항]\n\n- [링크](https://wkdtjsgur100.github.io/database-normalization/)', '2022-06-07', '36');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### [DB] Anomaly\n\n---\n\n> 정규화를 해야하는 이유는 잘못된 테이블 설계로 인해 Anomaly (이상 현상)가 나타나기 때문이다.\n>\n> 이 페이지에서는 Anomaly가 무엇인지 살펴본다.\n\n예) {Student ID, Course ID, Department, Course ID, Grade}\n\n1. 삽입 이상 (Insertion Anomaly)\n\n   기본키가 {Student ID, Course ID} 인 경우 -> Course를 수강하지 않은 학생은 Course ID가 없는 현상이 발생함. 결국 Course ID를 Null로 할 수밖에 없는데, 기본키는 Null이 될 수 없으므로, Table에 추가될 수 없음.\n\n   굳이 삽입하기 위해서는 \'미수강\'과 같은 Course ID를 만들어야 함.\n\n   > 불필요한 데이터를 추가해야지, 삽입할 수 있는 상황 = Insertion Anomaly\n\n   \n\n2. 갱신 이상 (Update Anomaly)\n\n   만약 어떤 학생의 전공 (Department) 이 \"컴퓨터에서 음악\"으로 바뀌는 경우.\n\n   모든 Department를 \"음악\"으로 바꾸어야 함. 그러나 일부를 깜빡하고 바꾸지 못하는 경우, 제대로 파악 못함.\n\n   > 일부만 변경하여, 데이터가 불일치 하는 모순의 문제 = Update Anomaly\n\n   \n\n3. 삭제 이상 (Deletion Anomaly)\n\n   만약 어떤 학생이 수강을 철회하는 경우, {Student ID, Department, Course ID, Grade}의 정보 중\n\n   Student ID, Department 와 같은 학생에 대한 정보도 함께 삭제됨.\n\n   > 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제 = Deletion Anomaly\n\n\n', '2022-06-07', '37');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# Index(인덱스)\n\n<br>\n\n#### 목적\n\n```\n추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조\n```\n\n테이블의 칼럼을 색인화한다.\n\n> 마치, 두꺼운 책의 목차와 같다고 생각하면 편하다.\n\n데이터베이스 안의 레코드를 처음부터 풀스캔하지 않고, B+ Tree로 구성된 구조에서 Index 파일 검색으로 속도를 향상시키는 기술이다.\n\n<br>\n\n<br>\n\n#### 파일 구성\n\n테이블 생성 시, 3가지 파일이 생성된다.\n\n- FRM : 테이블 구조 저장 파일\n- MYD : 실제 데이터 파일\n- MYI : Index 정보 파일 (Index 사용 시 생성)\n\n<br>\n\n사용자가 쿼리를 통해 Index를 사용하는 칼럼을 검색하게 되면, 이때 MYI 파일의 내용을 활용한다.\n\n<BR>\n\n#### 단점 \n\n* Index 생성시, .mdb 파일 크기가 증가한다.\n* **한 페이지를 동시에 수정할 수 있는 병행성**이 줄어든다.\n* 인덱스 된 Field에서 Data를 업데이트하거나, **Record를 추가 또는 삭제시 성능이 떨어진다.**\n* 데이터 변경 작업이 자주 일어나는 경우, **Index를 재작성**해야 하므로 성능에 영향을 미친다.\n\n<br>\n\n#### 상황 분석\n\n* ##### 사용하면 좋은 경우\n\n  (1) Where 절에서 자주 사용되는 Column\n\n  (2) 외래키가 사용되는 Column\n\n  (3) Join에 자주 사용되는 Column\n\n  <br>\n\n* ##### Index 사용을 피해야 하는 경우\n\n  (1) Data 중복도가 높은 Column\n\n  (2) DML이 자주 일어나는 Column\n\n<br>\n\n#### DML이 일어났을 때의 상황\n\n* ##### INSERT\n\n  기존 Block에 여유가 없을 때, 새로운 Data가 입력된다.\n\n  → 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행한다.\n\n  → Index split 작업 동안, 해당 Block의 Key 값에 대해서 DML이 블로킹 된다. (대기 이벤트 발생)\n\n* ##### DELETE\n\n  <Table과 Index 상황 비교>\n\n  Table에서 data가 delete 되는 경우 : Data가 지워지고, 다른 Data가 그 공간을 사용 가능하다.\n\n  Index에서 Data가 delete 되는 경우 : Data가 지워지지 않고, 사용 안 됨 표시만 해둔다.\n\n  → **Table의 Data 수와 Index의 Data 수가 다를 수 있음**\n\n* ##### UPDATE\n\n  Table에서 update가 발생하면 → Index는 Update 할 수 없다.\n\n  Index에서는 **Delete가 발생한 후, 새로운 작업의 Insert 작업** / 2배의 작업이 소요되어 힘들다.\n\n<br>\n\n<br>\n\n##### [참고사항]\n\n- [링크](https://lalwr.blogspot.com/2016/02/db-index.html)', '2022-06-07', '38');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# DB 트랜잭션(Transaction)\n\n<br>\n\n#### 트렌잭션이란?\n\n> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위\n\n<br>\n\n상태를 변화시킨다는 것 → **SQL 질의어를 통해 DB에 접근하는 것**\n\n```\n- SELECT\n- INSERT\n- DELETE\n- UPDATE\n```\n\n<br>\n\n작업 단위 → **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**\n\n```\n예시) 사용자 A가 사용자 B에게 만원을 송금한다.\n\n* 이때 DB 작업\n- 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경\n- 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경\n\n현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문\n→ 이를 통틀어 하나의 트랜잭션이라고 한다.\n- 위 두 쿼리문 모두 성공적으로 완료되어야만 \"하나의 작업(트랜잭션)\"이 완료되는 것이다. `Commit`\n- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`\n\n```\n\n<br>\n\n**즉, 하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다준다.**\n\n<br>\n\n#### 트랜잭션 특징\n\n---\n\n- 원자성(Atomicity)\n\n  > 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.\n\n- 일관성(Consistency)\n\n  > 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.\n\n- 독립성(Isolation)\n\n  > 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.\n\n- 지속성(Durability)\n\n  > 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.\n\n<br>\n\n##### Commit\n\n하나의 트랜잭션이 성공적으로 끝났고,  DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산\n\n<br>\n\n##### Rollback\n\n하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우\n\ntransaction이 정상적으로 종료되지 않았을 때, last consistent state (예) Transaction의 시작 상태) 로 roll back 할 수 있음. \n\n<br>\n\n*상황이 주어지면 DB 측면에서 어떻게 해결할 수 있을지 대답할 수 있어야 함*\n\n<br>\n\n---\n\n<br>\n\n#### Transaction 관리를 위한 DBMS의 전략\n\n이해를 위한 2가지 개념 : DBMS의 구조 / Buffer 관리 정책\n\n<br>\n\n1) DBMS의 구조\n\n> 크게 2가지 : Query Processor (질의 처리기), Storage System (저장 시스템)\n>\n> 입출력 단위 : 고정 길이의 page 단위로 disk에 읽거나 쓴다.\n>\n> 저장 공간 : 비휘발성 저장 장치인 disk에 저장, 일부분을 Main Memory에 저장\n\n<img src=\"https://d2.naver.com/content/images/2015/06/helloworld-407507-1.png\">\n\n<br>\n\n2) Page Buffer Manager or Buffer Manager\n\nDBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리하는 모듈\n\n> Buffer 관리 정책에 따라, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 가져온다.\n\n<br>\n\n3) UNDO\n\n필요한 이유 : 수정된 Page들이 **<u>Buffer 교체 알고리즘에 따라서 디스크에 출력</u>**될 수 있음. Buffer 교체는 **<u>transaction과는 무관하게 buffer의 상태에 따라서, 결정됨</u>**. 이로 인해, 정상적으로 종료되지 않은 transaction이 변경한 page들은 원상 복구 되어야 하는데,  이 복구를 undo라고 함.\n\n- 2개의 정책 (수정된 페이지를 디스크에 쓰는 시점으로 분류)\n\n  steal : 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책\n\n  - 대부분의 DBMS가 채택하는 Buffer 관리 정책\n  - UNDO logging과 복구를 필요로 함.\n\n  <br>\n\n  ¬steal : 수정된 페이지들을 EOT (End Of Transaction)까지는 버퍼에 유지하는 정책\n\n  - UNDO 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함.\n\n<br>\n\n4) REDO\n\n이미 commit한 transaction의 수정을 재반영하는 복구 작업\n\nBuffer 관리 정책에 영향을 받음\n\n- Transaction이 종료되는 시점에 해당 transaction이 수정한 page를 디스크에 쓸 것인가 아닌가로 기준.\n\n  <br>\n\n  FORCE : 수정했던 모든 페이지를 Transaction commit 시점에 disk에 반영\n\n  transaction이 commit 되었을 때 수정된 페이지들이 disk 상에 반영되므로 redo 필요 없음.\n\n  <br>\n\n  ¬FORCE : commit 시점에 반영하지 않는 정책\n\n  transaction이 disk 상의 db에 반영되지 않을 수 있기에 redo 복구가 필요. (대부분의 DBMS 정책)\n\n  <br>\n  \n  <br>\n\n#### [참고사항]\n\n- [링크](https://d2.naver.com/helloworld/407507)', '2022-06-07', '39');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 트랜잭션 격리 수준(Transaction Isolation Level)\n\n<br>\n\n#### **Isolation level** \n\n---\n\n트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준\n\n<br>\n\n#### Isolation level의 필요성\n\n----\n\n데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 한다.\n\n따라서 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.\n\n하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이다.\n\n그렇다고 해서, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 된다.\n\n- 따라서 최대한 효율적인 Locking 방법이 필요함!\n\n<br>\n\n#### Isolation level 종류\n\n----\n\n1. ##### Read Uncommitted (레벨 0)\n\n   > SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층\n\n   트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함\n\n   ```\n   사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다\n   ```\n\n   데이터베이스의 일관성을 유지하는 것이 불가능함\n\n   <br>\n\n2. ##### Read Committed (레벨 1)\n\n   > SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층\n\n   트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨\n\n   Commit이 이루어진 트랜잭션만 조회 가능\n\n   SQL 서버가 Default로 사용하는 Isolation Level임\n\n   ```\n   사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능함\n   ```\n\n   <br>\n\n3. ##### Repeatable Read (레벨 2)\n\n   > 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층\n\n   트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함\n\n   다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능\n\n   <br>\n\n4. ##### Serializable (레벨 3)\n\n   > 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층\n\n   완벽한 읽기 일관성 모드를 제공함\n\n   다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능\n\n   <br>\n\n<br>\n\n***선택 시 고려사항***\n\nIsolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있음\n\n동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨\n\n레벨을 높게 조정할 수록 발생하는 비용이 증가함\n\n<br>\n\n##### 낮은 단계 Isolation Level을 활용할 때 발생하는 현상들\n\n- Dirty Read\n\n  > 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상\n  >\n  > 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우\n\n- Non-Repeatable Read\n\n  > 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상\n\n- Phantom Read\n\n  > 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상\n  >\n  > 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임\n\n\n', '2022-06-07', '40');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# 저장 프로시저(Stored PROCEDURE)\n\n<br>\n\n```\n일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합\n```\n\n<br>\n\n데이터베이스에서 SQL을 통해 작업을 하다 보면, 하나의 쿼리문으로 원하는 결과를 얻을 수 없을 때가 생긴다. 원하는 결과물을 얻기 위해 사용할 여러줄의 쿼리문을 한 번의 요청으로 실행하면 좋지 않을까? 또한, 인자 값만 상황에 따라 바뀌고 동일한 로직의 복잡한 쿼리문을 필요할 때마다 작성한다면 비효율적이지 않을까?\n\n이럴 때 사용할 수 있는 것이 바로 프로시저다.\n\n<br>\n\n\n\n<img src=\"https://docs.oracle.com/cd/B13789_01/java.101/b12021/img/call_sto.gif\">\n\n<br>\n\n프로시저를 만들어두면, 애플리케이션에서 여러 상황에 따라 해당 쿼리문이 필요할 때 인자 값만 전달하여 쉽게 원하는 결과물을 받아낼 수 있다.\n\n<br>\n\n#### 프로시저 생성 및 호출\n\n```plsql\nCREATE OR REPLACE PROCEDURE 프로시저명(변수명1 IN 데이터타입, 변수명2 OUT 데이터타입) -- 인자 값은 필수 아님\nIS\n[\n변수명1 데이터타입;\n변수명2 데이터타입;\n..\n]\nBEGIN\n 필요한 기능; -- 인자값 활용 가능\nEND;\n\nEXEC 프로시저명; -- 호출\n```\n\n<br>\n\n#### 예시1 (IN)\n\n```plsql\nCREATE OR REPLACE PROCEDURE test( name IN VARCHAR2 ) \nIS\n	msg VARCHAR2(5) := \'내 이름은\';\nBEGIN \n	dbms_output.put_line(msg||\' \'||name); \nEND;\n\nEXEC test(\'규글\');\n```\n\n```\n내 이름은 규글\n```\n\n<br>\n\n#### 예시2 (OUT)\n\n```plsql\nCREATE OR REPLACE PROCEDURE test( name OUT VARCHAR2 ) \nIS\nBEGIN \n	name := \'Gyoogle\'\nEND;\n\nDECLARE\nout_name VARCHAR2(100);\n\nBEGIN\ntest(out_name);\ndbms_output.put_line(\'내 이름은 \'||out_name);\nEND;\n```\n\n```\n내 이름은 Gyoogle\n```\n\n<br>\n\n<br>\n\n### 프로시저 장점\n\n---\n\n1. #### 최적화 & 캐시\n\n   프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다.\n\n   만약 해당 프로세스가 여러번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.\n\n2. #### 유지 보수\n\n   작업이 변경될 때, 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다.\n   (But, 장점이 단점이 될 수도 있는 부분이기도.. )\n\n3. #### 트래픽 감소\n\n   클라이언트가 직접 SQL문을 작성하지 않고, 프로시저명에 매개변수만 담아 전달하면 된다. 즉, SQL문이 서버에 이미 저장되어 있기 때문에 클라이언트와 서버 간 네트워크 상 트래픽이 감소된다.\n\n4. #### 보안\n\n   프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.\n\n<br>\n\n### 프로시저 단점\n\n---\n\n1. #### 호환성\n\n   구문 규칙이 SQL / PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁘다.\n\n2. #### 성능\n\n   문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느리다.\n\n3. #### 디버깅\n\n   에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.\n\n<br>\n\n<br>\n\n#### [참고 자료]\n\n- [링크](https://ko.wikipedia.org/wiki/%EC%A0%80%EC%9E%A5_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80)\n- [링크](https://itability.tistory.com/51)', '2022-06-07', '41');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## Redis\n\n> 빠른 오픈 소스 인 메모리 키 값 데이터 구조 스토어\n\n보통 데이터베이스는 하드 디스크나 SSD에 저장한다. 하지만 Redis는 메모리(RAM)에 저장해서 디스크 스캐닝이 필요없어 매우 빠른 장점이 존재함\n\n캐싱도 가능해 실시간 채팅에 적합하며 세션 공유를 위해 세션 클러스터링에도 활용된다.`\n\n***RAM은 휘발성 아닌가요? 껐다키면 다 날아가는데..***\n\n이를 막기위한 백업 과정이 존재한다.\n\n- snapshot : 특정 지점을 설정하고 디스크에 백업\n- AOF(Append Only File) : 명령(쿼리)들을 저장해두고, 서버가 셧다운되면 재실행해서 다시 만들어 놓는 것\n\n데이터 구조는 key/value 값으로 이루어져 있다. (따라서 Redis는 비정형 데이터를 저장하는 비관계형 데이터베이스 관리 시스템이다)\n\n##### value 5가지\n\n1. String (text, binary data) - 512MB까지 저장이 가능함\n2. set (String 집합)\n3. sorted set (set을 정렬해둔 상태)\n4. Hash\n5. List (양방향 연결리스트도 가능)', '2022-06-07', '42');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## OSI 7 계층\n\n<br>\n\n<img src=\"https://s7280.pcdn.co/wp-content/uploads/2018/06/osi-model-7-layers-1.png\">\n\n<br>\n\n#### 7계층은 왜 나눌까?\n\n통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이다.\n\n<br>\n\n##### 1) 물리(Physical)\n\n> 리피터, 케이블, 허브 등\n\n단지 데이터 전기적인 신호로 변환해서 주고받는 기능을 진행하는 공간\n\n즉, 데이터를 전송하는 역할만 진행한다.\n\n<br>\n\n##### 2) 데이터 링크(Data Link)\n\n> 브릿지, 스위치 등\n\n물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할\n\nMac 주소를 통해 통신한다. 프레임에 Mac 주소를 부여하고 에러검출, 재전송, 흐름제어를 진행한다.\n\n<br>\n\n##### 3) 네트워크(Network)\n\n> 라우터, IP\n\n데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당한다.\n\n라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.\n\n라우팅, 흐름 제어, 오류 제어, 세그먼테이션 등을 수행한다.\n\n<br>\n\n##### 4) 전송(Transport)\n\n> TCP, UDP\n\nTCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해준다.\n\n- TCP : 신뢰성, 연결지향적\n\n- UDP : 비신뢰성, 비연결성, 실시간\n\n<br>\n\n##### 5) 세션(Session)\n\n> API, Socket\n\n데이터가 통신하기 위한 논리적 연결을 담당한다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있다.\n\n<br>\n\n##### 6) 표현(Presentation)\n\n> JPEG, MPEG 등\n\n데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다.\n\n파일 인코딩, 명령어를 포장, 압축, 암호화한다.\n\n<br>\n\n##### 7) 응용(Application)\n\n> HTTP, FTP, DNS 등\n\n최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.\n\n사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공한다.', '2022-06-07', '43');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## [TCP] 3 way handshake & 4 way handshake\n\n> 연결을 성립하고 해제하는 과정을 말한다\n\n<br>\n\n### 3 way handshake - 연결 성립\n\nTCP는 정확한 전송을 보장해야 한다. 따라서 통신하기에 앞서, 논리적인 접속을 성립하기 위해 3 way handshake 과정을 진행한다.\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/uploads/TCP-connection-1.png\">\n\n1) 클라이언트가 서버에게 SYN 패킷을 보냄 (sequence : x)\n\n2) 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (sequence : y, ACK : x + 1)\n\n3) 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄\n\n<br>\n\n이렇게 3번의 통신이 완료되면 연결이 성립된다. (3번이라 3 way handshake인 것)\n\n<br>\n\n<br>\n\n### 4 way handshake - 연결 해제\n\n연결 성립 후, 모든 통신이 끝났다면 해제해야 한다.\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/uploads/CN.png\">\n\n1) 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.\n\n2) 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다)\n\n3) 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.\n\n4) 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.)\n\n- 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed)\n\n- TIME_WAIT 시간이 끝나면 클라이언트도 닫는다 (Closed)\n\n<br>\n\n이렇게 4번의 통신이 완료되면 연결이 해제된다.\n\n<br>\n\n<br>\n\n##### [참고 자료]\n\n[링크](<https://www.geeksforgeeks.org/tcp-connection-termination/>)', '2022-06-07', '44');
insert into cscontent (cs_content, cs_regdate, cs_code) values('\n\n\n\n### TCP (흐름제어/혼잡제어)\n\n---\n\n#### 들어가기 전\n\n- TCP 통신이란?\n  - 네트워크 통신에서 신뢰적인 연결방식\n  - TCP는 기본적으로 unreliable network에서, reliable network를 보장할 수 있도록 하는 프로토콜\n  - TCP는 network congestion avoidance algorithm을 사용\n- reliable network를 보장한다는 것은 4가지 문제점 존재\n  - 손실 : packet이 손실될 수 있는 문제\n  - 순서 바뀜 : packet의 순서가 바뀌는 문제\n  - Congestion : 네트워크가 혼잡한 문제\n  - Overload : receiver가 overload 되는 문제\n- 흐름제어/혼잡제어란?\n  - 흐름제어 (endsystem 대 endsystem)\n    - 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법\n    - Flow Control은 receiver가 packet을 지나치게 많이 받지 않도록 조절하는 것\n    - 기본 개념은 receiver가 sender에게 현재 자신의 상태를 feedback 한다는 점\n  - 혼잡제어 : 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법\n- 전송의 전체 과정\n  - Application layer : sender application layer가 socket에 data를 씀.\n  - Transport layer : data를 segment에 감싼다. 그리고 network layer에 넘겨줌.\n  - 그러면 아랫단에서 어쨋든 receiving node로 전송이 됨. 이 때,  sender의 send buffer에 data를 저장하고, receiver는 receive buffer에 data를 저장함.\n  - application에서 준비가 되면 이 buffer에 있는 것을 읽기 시작함.\n  - 따라서 flow control의 핵심은 이 receiver buffer가 넘치지 않게 하는 것임.\n  - 따라서 receiver는 RWND(Receive WiNDow) : receive buffer의 남은 공간을 홍보함\n\n#### 1. 흐름제어 (Flow Control)\n\n- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.\n\n- 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번히 발생한다.\n\n- 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야한다.\n\n- 해결방법\n\n  - Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법\n\n    - <img src=\'https://t1.daumcdn.net/cfile/tistory/263B7D4E5715ECEB32\'>\n\n  - Sliding Window (Go Back N ARQ) \n\n    - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법\n\n    - 목적 : 전송은 되었지만, acked를 받지 못한 byte의 숫자를 파악하기 위해 사용하는 protocol\n\n      LastByteSent - LastByteAcked <= ReceivecWindowAdvertised\n\n      (마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남아있는 공간) ==\n\n      (현재 공중에 떠있는 패킷 수 <= sliding window)\n\n  - 동작방식 : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송\n\n    - <img src=\'https://t1.daumcdn.net/cfile/tistory/253F7E485715ED5F27\'>\n\n  - Window : TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 \'3 way handshaking\'을 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 된다.\n\n  - 세부구조\n\n    1. 송신 버퍼\n       - <img src=\'https://t1.daumcdn.net/cfile/tistory/22532F485715EDF218\'>- \n       - 200 이전의 바이트는 이미 전송되었고, 확인응답을 받은 상태\n       - 200 ~ 202 바이트는 전송되었으나 확인응답을 받지 못한 상태\n       - 203 ~ 211 바이트는 아직 전송이 되지 않은 상태\n    2. 수신 윈도우\n       - <img src=\'https://t1.daumcdn.net/cfile/tistory/25403A485715EE362B\'>\n    3. 송신 윈도우\n       - <img src=\'https://t1.daumcdn.net/cfile/tistory/2520244B5715EE6A14\'>\n       - 수신 윈도우보다 작거나 같은 크기로 송신 윈도우를 지정하게되면 흐름제어가 가능하다.\n    4. 송신 윈도우 이동\n       - <img src=\'https://t1.daumcdn.net/cfile/tistory/227DC8505715EEBA0A\'>\n       -  Before : 203 ~ 204를 전송하면 수신측에서는 확인 응답 203을 보내고, 송신측은 이를 받아 after 상태와 같이 수신 윈도우를 203 ~ 209 범위로 이동\n       - after : 205 ~ 209가 전송 가능한 상태\n    5. Selected Repeat\n\n<br>\n\n#### 2. 혼잡제어 (Congestion Control)\n\n- 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시키게 된다. 따라서 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.\n- 또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 혼잡제어라고 한다.\n- 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다루게 된다.\n- 해결 방법\n  - <img src=\'https://t1.daumcdn.net/cfile/tistory/256E39425715F10103\'>\n  - AIMD(Additive Increase / Multiplicative Decrease)\n    - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법\n    - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.\n    - 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.\n    - 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.\n  - Slow Start (느린 시작)\n    - AIMD 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재했다.\n    - Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배로 된다. \n    - 전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.\n    - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다. \n    - 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.\n  - Fast Retransmit (빠른 재전송)\n    - 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다. \n    - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다. \n    - 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.\n    - 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.\n  - Fast Recovery (빠른 회복)\n    - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.\n\n<br>\n\n[ref]<br>\n\n- <https://www.brianstorti.com/tcp-flow-control/>\n- <https://www.brianstorti.com/tcp-flow-control/>\n', '2022-06-07', '45');
insert into cscontent (cs_content, cs_regdate, cs_code) values('UDP란? \n\n---\n\n#### 들어가기 전\n\n- UDP 통신이란?\n\n  - User Datagram Protocol의 약자로 데이터를 데이터그램 단위로 처리하는 프로토콜이다. \n  - 비연결형, 신뢰성 없는 전송 프로토콜이다.\n  - 데이터그램 단위로 쪼개면서 전송을 해야하기 때문에 전송 계층이다.\n  - Transport layer에서 사용하는 프로토콜.\n\n- TCP와 UDP는 왜 나오게 됐는가?\n\n  1. IP의 역할은 Host to Host (장치 to 장치)만을 지원한다. 장치에서 장치로 이동은 IP로 해결되지만, 하나의 장비안에서 수많은 프로그램들이 통신을 할 경우에는 IP만으로는 한계가 있다.\n\n  2. 또한, IP에서 오류가 발생한다면 ICMP에서 알려준다. 하지만 ICMP는 알려주기만 할 뿐 대처를 못하기 때문에 IP보다 위에서 처리를 해줘야 한다.\n\n  - 1번을 해결하기 위하여 포트 번호가 나오게 됐고, 2번을 해결하기 위해 상위 프로토콜인 TCP와 UDP가 나오게 되었다.\n\n  * *ICMP : 인터넷 제어 메시지 프로토콜로 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송받는데 주로 쓰임\n\n- 그렇다면 TCP와 UDP가 어떻게 오류를 해결하는가?\n\n  - TCP : 데이터의 분실, 중복, 순서가 뒤바뀜 등을 자동으로 보정해줘서 송수신 데이터의 정확한 전달을 할 수 있도록 해준다.\n  - UDP : IP가 제공하는 정도의 수준만을 제공하는 간단한 IP 상위 계층의 프로토콜이다. TCP와는 다르게 에러가 날 수도 있고, 재전송이나 순서가 뒤바뀔 수도 있어서 이 경우, 어플리케이션에서 처리하는 번거로움이 존재한다.\n\n- UDP는 왜 사용할까?\n\n  - UDP의 결정적인 장점은 데이터의 신속성이다. 데이터의 처리가 TCP보다 빠르다.\n  - 주로 실시간 방송과 온라인 게임에서 사용된다. 네트워크 환경이 안 좋을때, 끊기는 현상을 생각하면 된다.\n\n- DNS(Domain Name Service)에서 UDP를 사용하는 이유\n\n  - Request의 양이 작음 -> UDP Request에 담길 수 있다.\n  - 3 way handshaking으로 연결을 유지할 필요가 없다. (오버헤드 발생)\n  - Request에 대한 손실은 Application Layer에서 제어가 가능하다.\n  - DNS : port 53번\n  - But, TCP를 사용할 때가 있다! 크기가 512(UDP 제한)이 넘을 때, TCP를 사용해야한다. \n\n<br>\n\n#### 1. UDP Header\n\n- <img src=\'https://t1.daumcdn.net/cfile/tistory/272A5A385759267B36\'>\n  - Source port : 시작 포트\n  - Destination port : 도착지 포트\n  - Length : 길이\n  - _Checksum_ : 오류 검출\n    - 중복 검사의 한 형태로, 오류 정정을 통해 공간이나 시간 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.\n\n<br>\n\n- 이렇게 간단하므로, TCP 보다 용량이 가볍고 송신 속도가 빠르게 작동됨. \n\n- 그러나 확인 응답을 못하므로, TCP보다 신뢰도가 떨어짐. \n- UDP는 비연결성, TCP는 연결성으로 정의할 수 있음.\n\n<br>\n\n#### DNS과 UDP 통신 프로토콜을 사용함.\n\nDNS는 데이터를 교환하는 경우임\n\n이때, TCP를 사용하게 되면, 데이터를 송신할 때까지 세션 확립을 위한 처리를 하고, 송신한 데이터가 수신되었는지 점검하는 과정이 필요하므로, Protocol overhead가 UDP에 비해서 큼.\n\n------\n\nDNS는 Application layer protocol임.\n\n모든 Application layer protocol은 TCP, UDP 중 하나의 Transport layer protocol을 사용해야 함.\n\n(TCP는 reliable, UDP는 not reliable임) / DNS는 reliable해야할 것 같은데 왜 UDP를 사용할까?\n\n\n\n사용하는 이유 \n\n1. TCP가 3-way handshake를 사용하는 반면, UDP는 connection 을 유지할 필요가 없음.\n\n2. DNS request는 UDP segment에 꼭 들어갈 정도로 작음.\n\n   DNS query는 single UDP request와 server로부터의 single UDP reply로 구성되어 있음.\n\n3. UDP는 not reliable이나, reliability는 application layer에 추가될 수 있음.\n   (Timeout 추가나, resend 작업을 통해)\n\nDNS는 UDP를 53번 port에서 사용함.\n\n------\n\n그러나 TCP를 사용하는 경우가 있음.\n\nZone transfer 을 사용해야하는 경우에는 TCP를 사용해야 함.\n\n(Zone Transfer : DNS 서버 간의 요청을 주고 받을 떄 사용하는 transfer)\n\n만약에 데이터가 512 bytes를 넘거나, 응답을 못받은 경우 TCP로 함.\n\n<br>\n\n[ref]<br>\n\n- <https://www.geeksforgeeks.org/why-does-dns-use-udp-and-not-tcp/>\n- <https://support.microsoft.com/en-us/help/556000>', '2022-06-07', '46');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 대칭키 & 공개키\n\n<br>\n\n#### 대칭키(Symmetric Key)\n\n> 암호화와 복호화에 같은 암호키(대칭키)를 사용하는 알고리즘\n\n동일한 키를 주고받기 때문에, 매우 빠르다는 장점이 있음\n\nbut, 대칭키 전달과정에서 해킹 위험에 노출\n\n<br>\n\n#### 공개키(Public Key)/비대칭키(Asymmetric Key)\n\n> 암호화와 복호화에 사용하는 암호키를 분리한 알고리즘\n\n대칭키의 키 분배 문제를 해결하기 위해 고안됨.(대칭키일 때는 송수신자 간만 키를 알아야하기 때문에 분배가 복잡하고 어렵지만 공개키와 비밀키로 분리할 경우, 남들이 알아도 되는 공개키만 공개하면 되므로)\n\n자신이 가지고 있는 고유한 암호키(비밀키)로만 복호화할 수 있는 암호키(공개키)를 대중에 공개함\n\n<br>\n\n##### 공개키 암호화 방식 진행 과정\n\n1) A가 웹 상에 공개된 \'B의 공개키\'를 이용해 평문을 암호화하여 B에게 보냄\n2) B는 자신의 비밀키로 복호화한 평문을 확인, A의 공개키로 응답을 암호화하여 A에개 보냄\n3) A는 자신의 비밀키로 암호화된 응답문을 복호화함\n\n하지만 이 방식은 Confidentiallity만 보장해줄 뿐, Integrity나 Authenticity는 보장해주지 못함\n\n-> 이는 MAC(Message Authentication Code)나 전자 서명(Digital Signature)으로 해결\n\n대칭키에 비해 암호화 복호화가 매우 복잡함\n\n(암호화하는 키가 복호화하는 키가 서로 다르기 때문)\n\n<br>\n\n<br>\n\n##### 대칭키와 공개키 암호화 방식을 적절히 혼합해보면? (하이브리드 방식)\n\n> SSL 탄생의 시초가 됨\n\n```\n1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄\n2. B는 암호문을 받고, 자신의 비밀키로 복호화함\n3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄\n4. A는 자신의 대칭키로 암호문을 복호화함\n5. 앞으로 이 대칭키로 암호화를 통신함\n```\n\n즉, 대칭키를 주고받을 때만 공개키 암호화 방식을 사용하고 이후에는 계속 대칭키 암호화 방식으로 통신하는 것!\n\n<BR>', '2022-06-07', '47');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## HTTP & HTTPS\n\n<br>\n\n- ##### HTTP(HyperText Transfer Protocol)\n\n  인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약\n\n<br>\n\nHTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다.\n\n이런 보안 문제를 해결해주는 프로토콜이 **\'HTTPS\'**\n\n<br>\n\n- ##### HTTPS(HyperText Transfer Protocol Secure)\n\n  인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약\n\nHTTPS는 텍스트를 암호화한다. (공개키 암호화 방식으로!) : [공개키 설명](https://github.com/kim6394/tech-interview-for-developer/blob/master/Computer%20Science/Network/%EB%8C%80%EC%B9%AD%ED%82%A4%20%26%20%EA%B3%B5%EA%B0%9C%ED%82%A4.md)\n\n<br>\n\n<br>\n\n#### HTTPS 통신 흐름\n\n1) 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.\n\n2) 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다.\n\n***CA란?*** : Certificate Authority로, 공개키를 저장해주는 신뢰성이 검증된 민간기업\n\n3) 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.\n\n4) A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.\n\n5) 클라이언트가 `main.html` 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.\n\nCA 기업의 공개키는 브라우저가 이미 알고있다. (세계적으로 신뢰할 수 있는 기업으로 등록되어 있기 때문에, 브라우저가 인증서를 탐색하여 해독이 가능한 것)\n\n6) 브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다. 이제 A서버와 통신할 대는 얻은 A서버의 공개키로 암호화해서 요청을 날리게 된다.\n\n<br>\n\nHTTPS도 무조건 안전한 것은 아니다. (신뢰받는 CA 기업이 아닌 자체 인증서 발급한 경우 등)\n\n이때는 HTTPS지만 브라우저에서 `주의 요함`, `안전하지 않은 사이트`와 같은 알림으로 주의 받게 된다.\n\n<br>\n\n##### [참고사항]\n\n[링크](<https://jeong-pro.tistory.com/89>)', '2022-06-07', '48');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# TLS/SSL HandShake\n\n<br>\n\n```\nHTTPS에서 클라이언트와 서버간 통신 전\nSSL 인증서로 신뢰성 여부를 판단하기 위해 연결하는 방식\n```\n\n<br>\n\n![image](https://user-images.githubusercontent.com/34904741/139517776-f2cac636-5ce5-4815-981d-33905283bf13.png)\n\n<br>\n\n### 진행 순서\n\n1. 클라이언트는 서버에게 `client hello` 메시지를 담아 서버로 보낸다.\n   이때 암호화된 정보를 함께 담는데, `버전`, `암호 알고리즘`, `압축 방식` 등을 담는다.\n\n   <br>\n\n2. 서버는 클라이언트가 보낸 암호 알고리즘과 압축 방식을 받고, `세션 ID`와 `CA 공개 인증서`를 `server hello` 메시지와 함께 담아 응답한다. 이 CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있다.\n\n   <br>\n\n3. 클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한 지 CA 목록에서 확인하는 과정을 진행한다.\n\n   <br>\n\n4. CA 인증서에 대한 신뢰성이 확보되었다면, 클라이언트는 난수 바이트를 생성하여 서버의 공개키로 암호화한다. 이 난수 바이트는 대칭키를 정하는데 사용이 되고, 앞으로 서로 메시지를 통신할 때 암호화하는데 사용된다.\n\n   <br>\n\n5. 만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구했다면, 클라이언트의 인증서와 클라이언트의 개인키로 암호화된 임의의 바이트 문자열을 함께 보내준다.\n\n   <br>\n\n6. 서버는 클라이언트의 인증서를 확인 후, 난수 바이트를 자신의 개인키로 복호화 후 대칭 마스터 키 생성에 활용한다.\n\n   <br>\n\n7. 클라이언트는 handshake 과정이 완료되었다는 `finished` 메시지를 서버에 보내면서, 지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보내준다.\n\n   <br>\n\n8. 서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는 지 확인한다. 일치하면 서버도 마찬가지로  `finished` 메시지를 이번에 만든 대칭키로 암호화하여 보낸다.\n\n   <br>\n\n9. 클라이언트는 해당 메시지를 대칭키로 복호화하여 서로 통신이 가능한 신뢰받은 사용자란 걸 인지하고, 앞으로 클라이언트와 서버는 해당 대칭키로 데이터를 주고받을 수 있게 된다.\n\n<br>\n\n<br>\n\n#### [참고 자료]\n\n- [링크](https://wangin9.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-URL-%EC%9E%85%EB%A0%A5-%ED%9B%84-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC%EB%93%A4-5TLSSSL-Handshake)', '2022-06-07', '49');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 로드 밸런싱(Load Balancing)\n\n> 둘 이상의 CPU or 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것\n\n<br>\n\n<img src=\"https://user-images.githubusercontent.com/88614978/172393034-17f83146-2b22-44e0-9a83-5e6d4e4b3087.png\" >\n\n요즘 시대에는 웹사이트에 접속하는 인원이 급격히 늘어나게 되었다.\n\n따라서 이 사람들에 대해 모든 트래픽을 감당하기엔 1대의 서버로는 부족하다. 대응 방안으로 하드웨어의 성능을 올리거나(Scale-up) 여러대의 서버가 나눠서 일하도록 만드는 것(Scale-out)이 있다. 하드웨어 향상 비용이 더욱 비싸기도 하고, 서버가 여러대면 무중단 서비스를 제공하는 환경 구성이 용이하므로 Scale-out이 효과적이다. 이때 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 바로 **로드 밸런싱**이다.\n\n<br>\n\n**로드 밸런싱**은 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할을 한다. Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식이다. 서비스를 운영하는 사이트의 규모에 따라 웹 서버를 추가로 증설하면서 로드 밸런서로 관리해주면 웹 서버의 부하를 해결할 수 있다.\n\n<br>\n\n#### 로드 밸런서가 서버를 선택하는 방식\n\n- 라운드 로빈(Round Robin) : CPU 스케줄링의 라운드 로빈 방식 활용\n- Least Connections : 연결 개수가 가장 적은 서버 선택 (트래픽으로 인해 세션이 길어지는 경우 권장)\n- Source : 사용자 IP를 해싱하여 분배 (특정 사용자가 항상 같은 서버로 연결되는 것 보장)\n\n<br>\n\n#### 로드 밸런서 장애 대비\n\n서버를 분배하는 로드 밸런서에 문제가 생길 수 있기 때문에 로드 밸런서를 이중화하여 대비한다.\n\n> Active 상태와 Passive 상태\n\n<br>\n\n##### [참고자료]\n\n- [링크](<https://www.educative.io/courses/grokking-the-system-design-interview/3jEwl04BL7Q>)\n\n- [링크](<https://nesoy.github.io/articles/2018-06/Load-Balancer>)\n', '2022-06-07', '50');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# [Network] Blocking/Non-blocking & Synchronous/Asynchronous\n\n<br>\n\n```\n동기/비동기는 우리가 일상 생활에서 많이 들을 수 있는 말이다.\n\nBlocking과 Synchronous, 그리고 Non-blocking과 Asysnchronous를\n서로 같은 개념이라고 착각하기 쉽다.\n\n각자 어떤 의미를 가지는지 간단하게 살펴보자\n```\n\n<br>\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fda50Yz%2Fbtq0Dsje4ZV%2FlGe8H8nZgdBdgFvo7IczS0%2Fimg.png\">\n\n<br>\n\n[homoefficio](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)님 블로그에 나온 2대2 매트릭스로 잘 정리된 사진이다. 이 사진만 보고 모두 이해가 된다면, 차이점에 대해 잘 알고 있는 것이다.\n\n<br>\n\n## Blocking/Non-blocking\n\n블럭/논블럭은 간단히 말해서 `호출된 함수`가 `호출한 함수`에게 제어권을 건네주는 유무의 차이라고 볼 수 있다.\n\n함수 A, B가 있고, A 안에서 B를 호출했다고 가정해보자. 이때 호출한 함수는 A고, 호출된 함수는 B가 된다. 현재 B가 호출되면서 B는 자신의 일을 진행해야 한다. (제어권이 B에게 주어진 상황)\n\n- **Blocking** : 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가지고 있는다. A는 B가 다 마칠 때까지 기다려야 한다.\n- **Non-blocking** : 함수 B는 할 일을 마치지 않았어도 A에게 제어권을 바로 넘겨준다. A는 B를 기다리면서도 다른 일을 진행할 수 있다.\n\n즉, 호출된 함수에서 일을 시작할 때 바로 제어권을 리턴해주느냐, 할 일을 마치고 리턴해주느냐에 따라 블럭과 논블럭으로 나누어진다고 볼 수 있다.\n\n<br>\n\n## Synchronous/Asynchronous\n\n동기/비동기는 일을 수행 중인 `동시성`에 주목하자\n\n아까처럼 함수 A와 B라고 똑같이 생각했을 때, B의 수행 결과나 종료 상태를 A가 신경쓰고 있는 유무의 차이라고 생각하면 된다.\n\n- **Synchronous** : 함수 A는 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크한다. \n- **Asynchronous** : 함수 B의 수행 상태를 B 혼자 직접 신경쓰면서 처리한다. (Callback)\n\n즉, 호출된 함수(B)를 호출한 함수(A)가 신경쓰는지, 호출된 함수(B) 스스로 신경쓰는지를 동기/비동기라고 생각하면 된다.\n\n비동기는 호출시 Callback을 전달하여 작업의 완료 여부를 호출한 함수에게 답하게 된다. (Callback이 오기 전까지 호출한 함수는 신경쓰지 않고 다른 일을 할 수 있음)\n\n<br>\n\n<br>\n\n위 그림처럼 총 4가지의 경우가 나올 수 있다. 이걸 좀 더 이해하기 쉽게 Case 별로 예시를 통해 보면서 이해하고 넘어가보자\n\n<br>\n\n```\n상황 : 치킨집에 직접 치킨을 사러감\n```\n\n<br>\n\n### 1) Blocking & Synchronous\n\n```\n나 : 사장님 치킨 한마리만 포장해주세요\n사장님 : 네 금방되니까 잠시만요!\n나 : 넹\n-- 사장님 치킨 튀기는 중--\n나 : (아 언제 되지?..궁금한데 그냥 멀뚱히 서서 치킨 튀기는거 보면서 기다림)\n```\n\n<br>\n\n### 2) Blocking & Asynchronous\n\n```\n나 : 사장님 치킨 한마리만 포장해주세요\n사장님 : 네 금방되니까 잠시만요!\n나 : 앗 넹\n-- 사장님 치킨 튀기는 중--\n나 : (언제 되는지 안 궁금함, 잠시만이래서 다 될때까지 서서 붙잡힌 상황)\n```\n\n<br>\n\n### 3) Non-blocking & Synchronous\n\n```\n나 : 사장님 치킨 한마리만 포장해주세요\n사장님 : 네~ 주문 밀려서 시간 좀 걸리니까 볼일 보시다 오세요\n나 : 넹\n-- 사장님 치킨 튀기는 중--\n(5분뒤) 나 : 제꺼 나왔나요?\n사장님 : 아직이요\n(10분뒤) 나 : 제꺼 나왔나요?\n사장님 : 아직이요ㅠ\n(15분뒤) 나 : 제꺼 나왔나요?\n사장님 : 아직이요ㅠㅠ\n```\n\n<br>\n\n### 4) Non-blocking & Asynchronous\n\n```\n나 : 사장님 치킨 한마리만 포장해주세요\n사장님 : 네~ 주문 밀려서 시간 좀 걸리니까 볼일 보시다 오세요\n나 : 넹\n-- 사장님 치킨 튀기는 중--\n나 : (앉아서 다른 일 하는 중)\n...\n사장님 : 치킨 나왔습니다\n나 : 잘먹겠습니다~\n```\n\n<br>\n\n#### [참고 사항]\n\n- [링크](http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/)\n- [링크](https://musma.github.io/2019/04/17/blocking-and-synchronous.html)\n', '2022-06-07', '51');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### Blocking I/O & Non-Blocking I/O\n\n---\n\n> I/O 작업은 Kernel level에서만 수행할 수 있다. 따라서, Process, Thread는 커널에게 I/O를 요청해야 한다.\n\n<br>\n\n1. #### Blocking I/O\n\n   I/O Blocking 형태의 작업은 \n\n   (1) Process(Thread)가 Kernel에게 I/O를 요청하는 함수를 호출\n\n   (2) Kernel이 작업을 완료하면 작업 결과를 반환 받음.\n\n   \n\n   * 특징\n     * I/O 작업이 진행되는 동안 user Process(Thread) 는 자신의 작업을 중단한 채 대기\n     * Resource 낭비가 심함 <br>(I/O 작업이 CPU 자원을 거의 쓰지 않으므로)\n\n   <br>\n\n   `여러 Client 가 접속하는 서버를 Blocking 방식으로 구현하는 경우` -> I/O 작업을 진행하는 작업을 중지 -> 다른 Client가 진행중인 작업을 중지하면 안되므로, client 별로 별도의 Thread를 생성해야 함 -> 접속자 수가 매우 많아짐\n\n   이로 인해, 많아진 Threads 로 *컨텍스트 스위칭 횟수가 증가함,,, 비효율적인 동작 방식*\n\n   <br>\n\n2. #### Non-Blocking I/O\n\n   I/O 작업이 진행되는 동안 User Process의 작업을 중단하지 않음. \n\n   * 진행 순서\n\n     1. User Process가 recvfrom 함수 호출 (커널에게 해당 Socket으로부터 data를 받고 싶다고 요청함)\n\n     2. Kernel은 이 요청에 대해서, 곧바로 recvBuffer를 채워서 보내지 못하므로, \"EWOULDBLOCK\"을 return함.\n\n     3. Blocking 방식과 달리, User Process는 다른 작업을 진행할 수 있음.\n\n     4. recvBuffer에 user가 받을 수 있는 데이터가 있는 경우, Buffer로부터 데이터를 복사하여 받아옴.\n\n        > 이때, recvBuffer는 Kernel이 가지고 있는 메모리에 적재되어 있으므로, Memory간 복사로 인해, I/O보다 훨씬 빠른 속도로 data를 받아올 수 있음.\n\n     5. recvfrom 함수는 빠른 속도로 data를 복사한 후, 복사한 data의 길이와 함께 반환함.\n\n\n\n\n', '2022-06-07', '52');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 운영 체제란 무엇인가?\n\n> **운영 체제(OS, Operating System)**\n>\n> : 하드웨어를 관리하고, 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 응용 프로그램과 하드웨어 간의 인터페이스로써 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.\n>\n> 즉, 운영 체제는 **사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 시스템 소프트웨어**라고 할 수 있다.\n>\n> (*종류로는 Windows, Linux, UNIX, MS-DOS 등이 있으며, 시스템의 역할 구분에 따라 각각 용이점이 있다.*)\n\n<br>\n\n---\n\n### [ 운영체제의 역할 ]\n\n<br>\n\n##### 1. 프로세스 관리\n\n- 프로세스, 스레드\n- 스케줄링\n- 동기화\n- IPC 통신\n\n##### 2. 저장장치 관리\n\n- 메모리 관리\n- 가상 메모리\n- 파일 시스템\n\n##### 3. 네트워킹\n\n- TCP/IP\n- 기타 프로토콜\n\n##### 4. 사용자 관리\n\n- 계정 관리\n- 접근권한 관리\n\n##### 5. 디바이스 드라이버\n\n- 순차접근 장치\n- 임의접근 장치\n- 네트워크 장치\n\n<br>\n\n---\n\n### [ 각 역할에 대한 자세한 설명 ]\n\n<br>\n\n### 1. 프로세스 관리\n\n운영체제에서 작동하는 응용 프로그램을 관리하는 기능이다.\n\n어떤 의미에서는 프로세서(CPU) 관리하는 것이라고 볼 수도 있다. 현재 CPU를 점유해야 할 프로세스를 결정하고, 실제로 CPU를 프로세스에 할당하며, 이 프로세스 간 공유 자원 접근과 통신 등을 관리하게 된다.\n\n<br>\n\n### 2. 저장장치 관리\n\n1차 저장장치에 해당하는 메인 메모리와 2차 저장장치에 해당하는 하드디스크, NAND 등을 관리하는 기능이다.\n\n- 1차 저장장치(Main Memory)\n  - 프로세스에 할당하는 메모리 영역의 할당과 해제\n  - 각 메모리 영역 간의 침범 방지\n  - 메인 메모리의 효율적 활용을 위한 가상 메모리 기능\n- 2차 저장장치(HDD, NAND Flash Memory 등)\n  - 파일 형식의 데이터 저장\n  - 이런 파일 데이터 관리를 위한 파일 시스템을 OS에서 관리\n  - `FAT, NTFS, EXT2, JFS, XFS` 등 많은 파일 시스템들이 개발되어 사용 중\n  <br>\n### 3. 네트워킹\n\n네트워킹은 컴퓨터 활용의 핵심과도 같아졌다.\n\nTCP/IP 기반의 인터넷에 연결하거나, 응용 프로그램이 네트워크를 사용하려면 **운영체제에서 네트워크 프로토콜을 지원**해야 한다. 현재 상용 OS들은 다양하고 많은 네트워크 프로토콜을 지원한다.\n\n이처럼 운영체제는 사용자와 컴퓨터 하드웨어 사이에 위치해서, 하드웨어를 운영 및 관리하고 명령어를 제어하여 응용 프로그램 및 하드웨어를 소프트웨어적으로 제어 및 관리를 해야한다.\n<br>\n### 4. 사용자 관리\n\n우리가 사용하는 PC는 오직 한 사람만의 것일까? 아니다.\n\n하나의 PC로도 여러 사람이 사용하는 경우가 많다. 그래서 운영체제는 한 컴퓨터를 여러 사람이 사용하는 환경도 지원해야 한다. 가족들이 각자의 계정을 만들어 PC를 사용한다면, 이는 하나의 컴퓨터를 여러 명이 사용한다고 말할 수 있다.\n\n따라서, 운영체제는 각 계정을 관리할 수 있는 기능이 필요하다. 사용자 별로 프라이버시와 보안을 위해 개인 파일에 대해선 다른 사용자가 접근할 수 없도록 해야 한다. 이 밖에도 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원하는 것이 사용자 관리 기능이다.\n<br>\n### 5. 디바이스 드라이버\n\n운영체제는 시스템의 자원, 하드웨어를 관리한다. 시스템에는 여러 하드웨어가 붙어있는데, 이들을 운영체제에서 인식하고 관리하게 만들어 응용 프로그램이 하드웨어를 사용할 수 있게 만들어야 한다.\n\n따라서, 운영체제 안에 하드웨어를 추상화 해주는 계층이 필요하다. 이 계층이 바로 디바이스 드라이버라고 불린다. 하드웨어의 종류가 많은 만큼, 운영체제 내부의 디바이스 드라이버도 많이 존재한다.\n\n이러한 수많은 디바이스 드라이버들을 관리하는 기능 또한 운영체제가 맡고 있다.\n\n---\n\n<br>\n\n##### [참고 자료 및 주제와 관련하여 참고하면 좋은 곳 링크]\n\n- 도서 - \'도전 임베디드 OS 만들기\' *( 이만우 저, 인사이트 출판 )*\n- 글 - \'운영체제란 무엇인가?\' *( https://coding-factory.tistory.com/300 )*', '2022-06-07', '53');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# 프로세스 & 스레드\n\n<br>\n\n> **프로세스** : 프로그램을 메모리 상에서 실행중인 작업\n>\n> **스레드** : 프로세스 안에서 실행되는 여러 흐름 단위\n\n<br>\n\n기본적으로 프로세스마다 최소 1개의 스레드 소유 (메인 스레드 포함)\n\n<br>\n\n![img](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)\n\n\n\n프로세스는 각각 별도의 주소공간 할당 (독립적)\n\n- Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)\n\n- Data : 전역변수, 정적변수, 배열 등\n    - 초기화 된 데이터는 data 영역에 저장\n    - 초기화 되지 않은 데이터는 bss 영역에 저장\n    \n- Heap : 동적 할당 시 사용 (new(), malloc() 등)\n\n- Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)\n\n<br>\n\n스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유\n\n<br>\n\n하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드 같이 생성\n\n<br>\n\n**프로세스는 자신만의 고유 공간과 자원을 할당받아 사용**하는데 반해, **스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**하는 차이가 존재함\n\n<br>\n\n<br>\n\n##### 멀티프로세스\n\n> 하나의 컴퓨터에 여러 CPU 장착 → 하나 이상의 프로세스들을 동시에 처리(병렬)\n\n**장점** : 안전성 (메모리 침범 문제를 OS 차원에서 해결)\n\n**단점** : 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생. Context Switching으로 인한 성능 저하\n\n<br>\n\n***Context Switching*이란?**\n\n> 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정\n>\n> 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말함\n>\n> → 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재함\n\n<br>\n\n<br>\n\n##### 멀티 스레드\n\n> 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것\n\n스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌\n\n<br>\n\n**장점** : 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소\n전역 변수와 정적 변수에 대한 자료 공유 가능\n\n**단점** : 안전성 문제. 하나의 스레드가 데이터 공간 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문) \n\n- 멀티스레드의 안전성에 대한 단점은 Critical Section 기법을 통해 대비함\n\n  > 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정\n  >\n  > ```\n  > 상호 배제, 진행, 한정된 대기를 충족해야함\n  > ```\n', '2022-06-07', '54');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 프로세스의 주소 공간\n\n> 프로그램이 CPU에 의해 실행됨 → 프로세스가 생성되고 메모리에 **\'프로세스 주소 공간\'**이 할당됨\n\n프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어져 있다.\n\n- **코드 Segment** : 프로그램 소스 코드 저장\n- **데이터 Segment** : 전역 변수 저장\n- **스택 Segment** : 함수, 지역 변수 저장\n\n<br>\n\n***왜 이렇게 구역을 나눈건가요?***\n\n최대한 데이터를 공유하여 메모리 사용량을 줄여야 합니다. \n\nCode는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유함\n\nStack과 데이터를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것!\n\n<br>\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/2174013858F1BED70A\">\n\n```\n프로그램의 함수와 지역 변수는, LIFO(가장 나중에 들어간게 먼저 나옴)특성을 가진 스택에서 실행된다. \n따라서 이 함수들 안에서 공통으로 사용하는 \'전역 변수\'는 따로 지정해주면 메모리를 아낄 수 있다.\n```', '2022-06-07', '55');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 인터럽트(Interrupt)\n\n##### 정의\n\n프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것\n<br>\n\n지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야한다.\n\n<br>\n\n외부/내부 인터럽트는 `CPU의 하드웨어 신호에 의해 발생`\n\n소프트웨어 인터럽트는 `명령어의 수행에 의해 발생`\n\n- ##### 외부 인터럽트\n\n  입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생\n\n  `전원 이상, 기계 착오, 외부 신호, 입출력`\n\n  <br>\n\n- ##### 내부 인터럽트\n\n  Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할 때 발생\n\n  > 0으로 나누기가 발생, 오버플로우, 명령어를 잘못 사용한 경우 (Exception)\n\n- ##### 소프트웨어 인터럽트\n\n  프로그램 처리 중 명령의 요청에 의해 발생한 것 (SVC 인터럽트)\n\n  > 사용자가 프로그램을 실행시킬 때 발생\n  >\n  > 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.\n\n<br>\n\n#### 인터럽트 발생 처리 과정\n\n<img src=\" https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2 \">\n\n주 프로그램이 실행되다가 인터럽트가 발생했다.\n\n현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다. (잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문)\n\n만약 **인터럽트 기능이 없었다면**, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다. (이를 **폴링(Polling)**이라고 한다)\n\n폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있었다.\n\n<br>\n\n즉, 컨트롤러가 입력을 받아들이는 방법(우선순위 판별방법)에는 두가지가 있다.\n\n- ##### 폴링 방식\n\n  사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식\n\n  인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다. (하드웨어에 비해 속도 느림)\n\n- ##### 인터럽트 방식\n\n  MCU 자체가 하드웨적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식\n\n  - Daisy Chain\n  - 병렬 우선순위 부여 \n\n<br>\n\n인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 **\'실시간 대응\'**이 필요할 때는 필수적인 기능이다.\n\n<br>\n\n즉, 인터럽트는 **발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법**이다.\n', '2022-06-07', '56');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### [Operating System] System Call\n\n---\n\nfork( ), exec( ), wait( )와 같은 것들은 Process 생성과 제어를 위한 System call임.\n\n- fork, exec는 새로운 Process 생성과 관련이 되어 있다.\n- wait는 Process (Parent)가 만든 다른 Process(child) 가 끝날 때까지 기다리는 명령어임.\n\n---\n\n##### Fork\n\n> 새로운 Process를 생성할 때 사용.\n>\n> 그러나, 이상한 방식임.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    printf(\"pid : %d\", (int) getpid()); // pid : 29146\n    \n    int rc = fork();					// 주목\n    \n    if (rc < 0) {\n        exit(1);\n    }									// (1) fork 실패\n    else if (rc == 0) {					// (2) child 인 경우 (fork 값이 0)\n        printf(\"child (pid : %d)\", (int) getpid());\n    }\n    else {								// (3) parent case\n        printf(\"parent of %d (pid : %d)\", rc, (int)getpid());\n    }\n}\n```\n\n> pid : 29146\n>\n> parent of 29147 (pid : 29146)\n>\n> child (pid : 29147)\n\n을 출력함 (parent와 child의 순서는 non-deterministic함. 즉, 확신할 수 없음. scheduler가 결정하는 일임.)\n\n[해석]\n\nPID :  프로세스 식별자. UNIX 시스템에서는 PID는 프로세스에게 명령을 할 때 사용함.\n\nFork()가 실행되는 순간. 프로세스가 하나 더 생기는데, 이 때 생긴 프로세스(Child)는 fork를 만든 프로세스(Parent)와 (almost) 동일한 복사본을 갖게 된다. **<u>이 때 OS는 위와 똑같은 2개의 프로그램이 동작한다고 생각하고, fork()가 return될 차례라고 생각한다.</u>** 그 때문에 새로 생성된 Process (child)는 main에서 시작하지 않고, if 문부터 시작하게 된다.\n\n그러나, 차이점이 있었다. 바로 child와 parent의 fork() 값이 다르다는 점이다.\n 따라서, 완전히 동일한 복사본이라 할 수 없다. \n\n> Parent의 fork()값 => child의 pid 값\n>\n> Child의 fork()값 => 0\n\nParent와 child의 fork 값이 다르다는 점은 매우 유용한 방식이다.\n\n그러나! Scheduler가 부모를 먼저 수행할지 아닐지 확신할 수 없다. 따라서 아래와 같이 출력될 수 있다.\n\n> pid : 29146\n>\n> child (pid : 29147)\n>\n> parent of 29147 (pid : 29146)\n\n----\n\n##### wait\n\n> child 프로세스가 종료될 때까지 기다리는 작업\n\n위의 예시에 int wc = wait(NULL)만 추가함.\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n    printf(\"pid : %d\", (int) getpid()); // pid : 29146\n    \n    int rc = fork();					// 주목\n    \n    if (rc < 0) {\n        exit(1);\n    }									// (1) fork 실패\n    else if (rc == 0) {					// (2) child 인 경우 (fork 값이 0)\n        printf(\"child (pid : %d)\", (int) getpid());\n    }\n    else {								// (3) parent case\n        int wc = wait(NULL)				// 추가된 부분\n        printf(\"parent of %d (wc : %d / pid : %d)\", wc, rc, (int)getpid());\n    }\n}\n```\n\n> pid : 29146\n>\n> child (pid : 29147)\n>\n> parent of 29147 (wc : 29147 / pid : 29146)\n\nwait를 통해서, child의 실행이 끝날 때까지 기다려줌. parent가 먼저 실행되더라도, wait ()는 child가 끝나기 전에는 return하지 않으므로, 반드시 child가 먼저 실행됨.\n\n----\n\n##### exec\n\n단순 fork는 동일한 프로세스의 내용을 여러 번 동작할 때 사용함.\n\nchild에서는 parent와 다른 동작을 하고 싶을 때는 exec를 사용할 수 있음.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n    printf(\"pid : %d\", (int) getpid()); // pid : 29146\n    \n    int rc = fork();					// 주목\n    \n    if (rc < 0) {\n        exit(1);\n    }									// (1) fork 실패\n    else if (rc == 0) {					// (2) child 인 경우 (fork 값이 0)\n        printf(\"child (pid : %d)\", (int) getpid());\n        char *myargs[3];\n        myargs[0] = strdup(\"wc\");		// 내가 실행할 파일 이름\n        myargs[1] = strdup(\"p3.c\");		// 실행할 파일에 넘겨줄 argument\n        myargs[2] = NULL;				// end of array\n        execvp(myarges[0], myargs);		// wc 파일 실행.\n        printf(\"this shouldn\'t print out\") // 실행되지 않음.\n    }\n    else {								// (3) parent case\n        int wc = wait(NULL)				// 추가된 부분\n        printf(\"parent of %d (wc : %d / pid : %d)\", wc, rc, (int)getpid());\n    }\n}\n```\n\nexec가 실행되면, \n\nexecvp( 실행 파일, 전달 인자 ) 함수는, code segment 영역에 실행 파일의 코드를 읽어와서 덮어 씌운다.\n\n씌운 이후에는,  heap, stack, 다른 메모리 영역이 초기화되고, OS는 그냥 실행한다. 즉, 새로운 Process를 생성하지 않고, 현재 프로그램에 wc라는 파일을 실행한다. 그로인해서, execvp() 이후의 부분은 실행되지 않는다.', '2022-06-07', '57');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## PCB & Context Switching\n\n<br>\n\n#### Process Management\n\n> CPU가 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것을 말함\n\n이때, CPU는 각 프로세스들이 누군지 알아야 관리가 가능함\n\n프로세스들의 특징을 갖고있는 것이 바로 `Process Metadata`\n\n- Process Metadata\n  - Process ID\n  - Process State\n  - Process Priority\n  - CPU Registers\n  - Owner\n  - CPU Usage\n  - Memeory Usage\n\n이 메타데이터는 프로세스가 생성되면 `PCB(Process Control Block)`이라는 곳에 저장됨\n\n<br>\n\n#### PCB(Process Control Block)\n\n> 프로세스 메타데이터들을 저장해 놓는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/25673A5058F211C224\" width=\"400\">\n\n##### 다시 정리해보면?\n\n```\n프로그램 실행 → 프로세스 생성 → 프로세스 주소 공간에 (코드, 데이터, 스택) 생성 \n→ 이 프로세스의 메타데이터들이 PCB에 저장\n```\n\n<br>\n\n##### PCB가 왜 필요한가요?\n\n> CPU에서는 프로세스의 상태에 따라 교체작업이 이루어진다. (interrupt가 발생해서 할당받은 프로세스가 waiting 상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때)\n>\n> 이때, **앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것**이다.\n\n##### PCB는 어떻게 관리되나요?\n\n> Linked List 방식으로 관리함\n>\n> PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이함.\n>\n> 즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거됨\n\n<br>\n\n<br>\n\n이렇게 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것을 `Context Switching`이라고 한다.\n\n#### Context Switching\n\n> CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정\n\n보통 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가시간을 모두 소모하거나, 입출력을 위해 대기해야 하는 경우에 Context Switching이 발생\n\n`즉, 프로세스가 Ready → Running, Running → Ready, Running → Waiting처럼 상태 변경 시 발생!` \n\n<br>\n\n##### Context Switching의 OverHead란?\n\noverhead는 과부하라는 뜻으로 보통 안좋은 말로 많이 쓰인다.\n\n하지만 프로세스 작업 중에는 OverHead를 감수해야 하는 상황이 있다.\n\n```\n프로세스를 수행하다가 입출력 이벤트가 발생해서 대기 상태로 전환시킴\n이때, CPU를 그냥 놀게 놔두는 것보다 다른 프로세스를 수행시키는 것이 효율적\n```\n\n즉, CPU에 계속 프로세스를 수행시키도록 하기 위해서 다른 프로세스를 실행시키고 Context Switching 하는 것\n\nCPU가 놀지 않도록 만들고, 사용자에게 빠르게 일처리를 제공해주기 위한 것이다.', '2022-06-07', '58');
insert into cscontent (cs_content, cs_regdate, cs_code) values('### IPC(Inter Process Communication)\n\n---\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/99DB8C495C4C570417\">\n\n<br>\n\n프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다. (스레드는 프로세스 안에서 자원을 공유하므로 영향을 받는다)\n\n이런 독립적 구조를 가진 **프로세스 간의 통신**을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 IPC 통신이다.\n\n<br>\n\n프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.\n\n***커널이란?***\n\n> 운영체제의 핵심적인 부분으로, 다른 모든 부분에 여러 기본적인 서비스를 제공해줌\n\n<br>\n\nIPC 설비 종류도 여러가지가 있다. 필요에 따라 IPC 설비를 선택해서 사용해야 한다.\n\n<br>\n\n#### IPC 종류\n\n1. ##### 익명 PIPE\n\n   > 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다.\n   >\n   > **한쪽 방향으로만 통신이 가능한 반이중 통신**이라고도 부른다.\n   >\n   > 따라서 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야 한다.\n   >\n   > \n   >\n   >\n   > 매우 간단하게 사용할 수 있는 장점이 있고, 단순한 데이터 흐름을 가질 땐 파이프를 사용하는 것이 효율적이다. 단점으로는 전이중 통신을 위해 2개를 만들어야 할 때는 구현이 복잡해지게 된다.\n\n   <br>\n\n2. ##### Named PIPE(FIFO)\n\n   > 익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용한다. (부모-자식 프로세스 간 통신처럼)\n   >\n   > Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신에 사용한다.\n   >\n   > 즉, 익명 파이프의 확장된 상태로 **부모 프로세스와 무관한 다른 프로세스도 통신이 가능한 것** (통신을 위해 이름있는 파일을 사용)\n   >\n   > \n   >\n   >\n   > 하지만, Named 파이프 역시 읽기/쓰기 동시에 불가능함. 따라서 전이중 통신을 위해서는 익명 파이프처럼 2개를 만들어야 가능\n\n   <br>\n\n3. ##### Message Queue\n\n   > 입출력 방식은 Named 파이프와 동일함\n   >\n   > 다른점은 메시지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이다.\n   >\n   > \n   >\n   >\n   > 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.\n\n   <br>\n\n4. ##### 공유 메모리\n\n   > 파이프, 메시지 큐가 통신을 이용한 설비라면, **공유 메모리는 데이터 자체를 공유하도록 지원하는 설비**다.\n   > \n   >\n   > 프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근하지 못하도록 반드시 보호되야한다. 하지만 다른 프로세스가 데이터를 사용하도록 해야하는 상황도 필요할 것이다. 파이프를 이용해 통신을 통해 데이터 전달도 가능하지만, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다.\n   > \n   >\n   > 공유 메모리는 **프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용**해준다.\n   >\n   > 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다.\n   >\n   > - **중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동함**\n\n   <br>\n\n5. ##### 메모리 맵\n\n   > 공유 메모리처럼 메모리를 공유해준다. 메모리 맵은 **열린 파일을 메모리에 맵핑시켜서 공유**하는 방식이다. (즉 공유 매개체가 파일+메모리)\n   >\n   > 주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.\n\n   <br>\n\n6. ##### 소켓\n\n   > 네트워크 소켓 통신을 통해 데이터를 공유한다.\n   >\n   > 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.\n   >\n   > 서버(bind, listen, accept), 클라이언트(connect)\n\n   <br>\n\n\n\n<br>\n\n이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)', '2022-06-07', '59');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# CPU Scheduling\n\n<br>\n\n### 1. 스케줄링\n\n> CPU 를 잘 사용하기 위해 프로세스를 잘 배정하기\n\n- 조건 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓\n- 목표\n    1. `Batch System`: 가능하면 많은 일을 수행. 시간(time) 보단 처리량(throughout)이 중요\n    2. `Interactive System`: 빠른 응답 시간. 적은 대기 시간.\n    3. `Real-time System`: 기한(deadline) 맞추기.\n\n### 2. 선점 / 비선점 스케줄링\n\n- 선점 (preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우 (처리시간 예측 어려움)\n- 비선점 (nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 용이함)\n\n### 3. 프로세스 상태\n\n![download (5)](https://user-images.githubusercontent.com/13609011/91695344-f2dfae80-eba8-11ea-9a9b-702192316170.jpeg)\n- 선점 스케줄링 : `Interrupt`, `I/O or Event Completion`, `I/O or Event Wait`, `Exit`\n- 비선점 스케줄링 : `I/O or Event Wait`, `Exit`\n\n---\n\n**프로세스의 상태 전이**\n\n✓ **승인 (Admitted)** : 프로세스 생성이 가능하여 승인됨.\n\n✓ **스케줄러 디스패치 (Scheduler Dispatch)** : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.\n\n✓ **인터럽트 (Interrupt)** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.\n\n✓ **입출력 또는 이벤트 대기 (I/O or Event wait)** : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.\n\n✓ **입출력 또는 이벤트 완료 (I/O or Event Completion)** : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것.\n\n### 4. CPU 스케줄링의 종류\n\n- 비선점 스케줄링\n    1. FCFS (First Come First Served)\n        - 큐에 도착한 순서대로 CPU 할당\n        - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐\n    2. SJF (Shortest Job First)\n        - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행\n        - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리\n    3. HRN (Hightest Response-ratio Next)\n        - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)\n        - 우선순위 = (대기시간 + 실행시간) / (실행시간)\n\n- 선점 스케줄링\n    1. Priority Scheduling\n        - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리\n        - 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation 이 생길 수 있음\n        - Aging 방법으로 Starvation 문제 해결 가능\n    2. Round Robin\n        - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 `Time Quantum` 만큼 CPU를 할달 받음\n            - `Time Quantum` or `Time Slice` : 실행의 최소 단위 시간\n        - 할당 시간(`Time Quantum`)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가\n    3. Multilevel-Queue (다단계 큐)\n    \n        ![Untitled1](https://user-images.githubusercontent.com/13609011/91695428-16a2f480-eba9-11ea-8d91-17d22bab01e5.png)\n        - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법\n        ![Untitled](https://user-images.githubusercontent.com/13609011/91695480-2a4e5b00-eba9-11ea-8dbf-390bf0a73c10.png)\n\n        - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용\n        - 우선순위가 높은 큐는 작은 `Time Quantum` 할당. 우선순위가 낮은 큐는 큰 `Time Quantum` 할당.\n    4. Multilevel-Feedback-Queue (다단계 피드백 큐)\n\n        ![Untitled2](https://user-images.githubusercontent.com/13609011/91695489-2cb0b500-eba9-11ea-8578-6602fee742ed.png)\n\n        - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐 그대로\n            - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문\n        - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌\n        - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄옂줌\n\n### 5. CPU 스케줄링 척도\n\n1. Response Time\n    - 작업이 처음 실행되기까지 걸린 시간\n2. Turnaround Time\n    - 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간\n\n---\n\n### 출처\n\n- 스케줄링 목표 : [링크](https://jhnyang.tistory.com/29?category=815411)\n- 프로세스 전이도 그림 출처 : [링크](https://rebas.kr/852)\n- CPU 스케줄링 종류 및 정의 참고 : [링크](https://m.blog.naver.com/PostView.nhn?blogId=so_fragrant&logNo=80056608452&proxyReferer=https:%2F%2Fwww.google.com%2F)\n- 다단계큐 참고 : [링크](https://jhnyang.tistory.com/28)\n- 다단계 피드백 큐 참고 : [링크](https://jhnyang.tistory.com/156)', '2022-06-07', '60');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 데드락 (DeadLock, 교착 상태)\n\n> 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태\n>\n> 무한히 다음 자원을 기다리게 되는 상태를 말한다.\n>\n> 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.\n\n> *(마치, 외나무 다리의 양 끝에서 서로가 비켜주기를 기다리고만 있는 것과 같다.)*\n\n<br>\n\n* 데드락이 일어나는 경우\n\n<img src=\"https://t1.daumcdn.net/cfile/tistory/243E89355714C26E28\">\n\n프로세스1과 2가 자원1, 2를 모두 얻어야 한다고 가정해보자\n\nt1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음\n\nt2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림\n\n<br>\n\n현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐\n\n→ 이것이 바로 **DeadLock**!!!!!!\n\n<br>\n\n(주로 발생하는 경우)\n\n> 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생\n>\n> 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이때 프로세스는 대기 상태로 들어감\n>\n> 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 \'교착 상태\' 발생\n\n<br>\n\n##### *데드락(DeadLock) 발생 조건*\n\n> 4가지 모두 성립해야 데드락 발생\n>\n> (하나라도 성립하지 않으면 데드락 문제 해결 가능)\n\n1. ##### 상호 배제(Mutual exclusion)\n\n   > 자원은 한번에 한 프로세스만 사용할 수 있음\n\n2. ##### 점유 대기(Hold and wait)\n\n   > 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함\n\n3. ##### 비선점(No preemption)\n\n   > 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음\n\n4. ##### 순환 대기(Circular wait)\n\n   > 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함\n\n<br>\n\n##### *데드락(DeadLock) 처리*\n\n---\n\n##### 교착 상태를 예방 & 회피\n\n1. ##### 예방(prevention)\n\n   교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)\n\n   > - 상호배제 부정 : 여러 프로세스가 공유 자원 사용\n   > - 점유대기 부정 : 프로세스 실행전 모든 자원을 할당\n   > - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납\n   > - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구\n\n2. ##### 회피(avoidance)\n\n   교착 상태 발생 시 피해나가는 방법\n\n   > 은행원 알고리즘(Banker\'s Algorithm)\n   >\n   > - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함\n   > - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피\n   > - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기\n\n\n\n##### 교착 상태를 탐지 & 회복\n\n교착 상태가 되도록 허용한 다음 회복시키는 방법\n\n1. ##### 탐지(Detection)\n\n   자원 할당 그래프를 통해 교착 상태를 탐지함\n\n   자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함\n\n2. ##### 회복(Recovery)\n\n   교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법\n\n   > ##### 프로세스 종료 방법\n   >\n   > - 교착 상태의 프로세스를 모두 중지\n   > - 교착 상태가 제거될 때까지 하나씩 프로세스 중지\n   >\n   > ##### 자원 선점 방법\n   >\n   > - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)\n   > - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점\n\n\n\n\n\n#### 주요 질문\n\n1. 데드락(교착 상태)가 뭔가요? 발생 조건에 대해 말해보세요.\n\n2. 회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.\n\n3. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요.\n\n   > 교착 상태 해결책\n   >\n   > 1. n명이 앉을 수 있는 테이블에서 철학자를 n-1명만 앉힘\n   > 2. 한 철학자가 젓가락 두개를 모두 집을 수 있는 상황에서만 젓가락 집도록 허용\n   > 3. 누군가는 왼쪽 젓가락을 먼저 집지 않고 오른쪽 젓가락을 먼저 집도록 허용', '2022-06-07', '61');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## [OS] Race Condition\n\n공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태\n\n> 동시 접근 시 자료의 일관성을 해치는 결과가 나타남\n\n<br>\n\n#### Race Condition이 발생하는 경우\n\n1. ##### 커널 작업을 수행하는 중에 인터럽트 발생\n\n   - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우\n   - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.\n\n2. ##### 프로세스가 \'System Call\'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때\n\n   - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )\n   - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함\n\n3. ##### 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때\n\n   - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우\n   - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법\n\n   \n', '2022-06-07', '62');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 세마포어(Semaphore) & 뮤텍스(Mutex)\n\n<br>\n\n공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.\n\n이를 위해 나온 것이 바로 **\'세마포어\'**\n\n**세마포어** : 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법\n\n<br>\n\n##### 임계 구역(Critical Section)\n\n> 여러 프로세스가 데이터를 공유하며 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**\n\n공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.\n\n<br>\n\n#### 세마포어 P, V 연산\n\nP : 임계 구역 들어가기 전에 수행 ( 프로세스 진입 여부를 자원의 개수(S)를 통해 결정)\n\nV : 임계 구역에서 나올 때 수행 ( 자원 반납 알림, 대기 중인 프로세스를 깨우는 신호 )\n\n<br>\n\n##### 구현 방법\n\n```sql\nP(S);\n\n// --- 임계 구역 ---\n\nV(S);\n```\n\n<br>\n\n```sql\nprocedure P(S)   --> 최초 S값은 1임\n    while S=0 do wait  --> S가 0면 1이 될때까지 기다려야 함\n    S := S-1   --> S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함\nend P\n\n--- 임계 구역 ---\n\nprocedure V(S) --> 현재상태는 S가 0임\n    S := S+1   --> S를 1로 원위치시켜 해제하는 과정\nend V\n```\n\n이를 통해, 한 프로세스가 P 혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다. P와 V를 사용하여 임계 구역에 대한 상호배제 구현이 가능하게 되었다.\n\n***예시***\n\n> 최초 S 값은 1이고, 현재 해당 구역을 수행할 프로세스 A, B가 있다고 가정하자\n\n1. 먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감\n2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기 상태\n3. A가 임계구역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 됨\n4. B는 이제 P(S)에서 while문을 빠져나올 수 있고, 임계구역으로 들어가 수행함\n\n<br>\n\n<br>\n\n**뮤텍스** : 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술\n\n> 상호 배제(**Mut**ual **Ex**clusion)의 약자임\n\n해당 접근을 조율하기 위해 lock과 unlock을 사용한다.\n\n- lock : 현재 임계 구역에 들어갈 권한을 얻어옴 ( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기 )\n- unlock : 현재 임계 구역을 모두 사용했음을 알림. ( 대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음 )\n\n<br>\n\n뮤텍스는 상태가 0, 1로 **이진 세마포어**로 부르기도 함\n\n<br>\n\n#### **뮤텍스 알고리즘**\n\n1. ##### 데커(Dekker) 알고리즘\n\n   flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식\n\n   - flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수\n   - turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수\n\n   ```java\n   while(true) {\n       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도\n       while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인\n           if(turn == j) { // j가 임계 구역 사용 중이면\n               flag[i] = false; // 프로세스 i 진입 취소\n               while(turn == j); // turn이 j에서 변경될 때까지 대기\n               flag[i] = true; // j turn이 끝나면 다시 진입 시도\n           }\n       }\n   }\n   \n   // ------- 임계 구역 ---------\n   \n   turn = j; // 임계 구역 사용 끝나면 turn을 넘김\n   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림\n   ```\n\n   <br>\n\n2. ##### 피터슨(Peterson) 알고리즘\n\n   데커와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있음\n\n   ```java\n   while(true) {\n       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도\n       turn = j; // 다른 프로세스에게 진입 기회 양보\n       while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기\n       }\n   }\n   \n   // ------- 임계 구역 ---------\n   \n   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림\n   ```\n\n   <br>\n\n3. ##### 제과점(Bakery) 알고리즘\n\n   여러 프로세스/스레드에 대한 처리가 가능한 알고리즘. 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.\n\n   ```java\n   while(true) {\n       \n       isReady[i] = true; // 번호표 받을 준비\n       number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 \n       isReady[i] = false; // 번호표 수령 완료\n       \n       for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교\n           while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기\n           while(number[j] && number[j] < number[i] && j < i);\n           \n           // 프로세스 j가 번호표 가지고 있어야 함\n           // 프로세스 j의 번호표 < 프로세스 i의 번호표\n       }\n   }\n   \n   // ------- 임계 구역 ---------\n   \n   number[i] = 0; // 임계 구역 사용 종료\n   ```\n\n   ', '2022-06-07', '63');
insert into cscontent (cs_content, cs_regdate, cs_code) values('### 페이징과 세그먼테이션\n\n---\n\n##### 기법을 쓰는 이유\n\n> 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요해서\n\n<br>\n\n#### 메모리 관리 기법\n\n1. 연속 메모리 관리\n\n   > 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함\n\n   - 고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할 (**내부 단편화 발생**)\n   - 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 (**외부 단편화 발생**)\n\n   <br>\n\n2. 불연속 메모리 관리\n\n   > 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법\n\n   페이지 : 고정 사이즈의 작은 프로세스 조각\n\n   프레임 : 페이지 크기와 같은 주기억장치 메모리 조각\n\n   단편화 : 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상\n\n   세그먼트 : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것\n   <br>\n\n   **고정 크기** : 페이징(Paging)\n\n   **가변 크기** : 세그먼테이션(Segmentation)\n   <br>\n\n   - 단순 페이징\n\n     > 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨\n     >\n     > 외부 단편화 X\n     >\n     > 소량의 내부 단편화 존재\n\n   - 단순 세그먼테이션\n\n     > 각 프로세스는 여러 세그먼트들로 나뉨\n     >\n     > 내부 단편화 X, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소\n     >\n     > 외부 단편화 존재\n\n   - 가상 메모리 페이징\n\n     > 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요X\n     >\n     > 필요한 페이지가 있으면 나중에 자동으로 불러들어짐\n     >\n     > 외부 단편화 X\n     >\n     > 복잡한 메모리 관리로 오버헤드 발생\n\n   - 가상 메모리 세그먼테이션\n\n     > 필요하지 않은 세그먼트들은 로드되지 않음\n     >\n     > 필요한 세그먼트 있을때 나중에 자동으로 불러들어짐\n     >\n     > 내부 단편화X\n     >\n     > 복잡한 메모리 관리로 오버헤드 발생\n', '2022-06-07', '64');
insert into cscontent (cs_content, cs_regdate, cs_code) values('### 페이지 교체 알고리즘\n\n---\n\n> 페이지 부재 발생 → 새로운 페이지를 할당해야 함 → 현재 할당된 페이지 중 어떤 것 교체할 지 결정하는 방법\n\n<br>\n\n- 좀 더 자세하게 생각해보면?\n\n가상 메모리는 `요구 페이지 기법`을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둠\n\n하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음\n\n따라서 메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 out하고, 해당 공간에 현재 필요한 페이지를 in 시켜야 함\n\n여기서 어떤 페이지를 out 시켜야할 지 정해야 함. (이때 out 되는 페이지를 victim page라고 부름) \n\n기왕이면 수정이 되지 않는 페이지를 선택해야 좋음\n(Why? : 만약 수정되면 메인 메모리에서 내보낼 때, 하드디스크에서 또 수정을 진행해야 하므로 시간이 오래 걸림)\n\n> 이와 같은 상황에서 상황에 맞는 페이지 교체를 진행하기 위해 페이지 교체 알고리즘이 존재하는 것!\n\n<br>\n\n##### Page Reference String\n\n> CPU는 논리 주소를 통해 특정 주소를 요구함\n>\n> 메인 메모리에 올라와 있는 주소들은 페이지의 단위로 가져오기 때문에 페이지 번호가 연속되어 나타나게 되면 페이지 결함 발생 X\n>\n> 따라서 CPU의 주소 요구에 따라 페이지 결함이 일어나지 않는 부분은 생략하여 표시하는 방법이 바로 `Page Reference String`\n\n<br>\n\n1. ##### FIFO 알고리즘\n\n   > First-in First-out, 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘\n\n   victim page : out 되는 페이지는, 가장 먼저 메모리에 올라온 페이지\n\n   가장 간단한 방법으로, 특히 초기화 코드에서 적절한 방법임\n\n   `초기화 코드` : 처음 프로세스 실행될 때 최초 초기화를 시키는 역할만 진행하고 다른 역할은 수행하지 않으므로, 메인 메모리에서 빼도 괜찮음\n\n   하지만 처음 프로세스 실행시에는 무조건 필요한 코드이므로, FIFO 알고리즘을 사용하면 초기화를 시켜준 후 가장 먼저 내보내는 것이 가능함\n\n   \n\n   <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FVQCGK%2FbtquJuqRkyS%2FLb3NgwHkBve08YhZpLkq31%2Fimg.png\">\n\n<br>\n\n<br>\n\n2. ##### OPT 알고리즘\n\n   > Optimal Page Replacement 알고리즘, 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄\n\n   FIFO에 비해 페이지 결함의 횟수를 많이 감소시킬 수 있음\n\n   하지만, 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없기 때문에 수행하기 어려운 알고리즘임\n\n   <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FSvRs7%2FbtquHbeJLQX%2FWXmK7xdGUbIxl43t0JG6Qk%2Fimg.png\">\n\n<br>\n\n3. ##### LRU 알고리즘\n\n   > Least-Recently-Used, 최근에 사용하지 않은 페이지를 가장 먼저 내려보내는 알고리즘\n\n   최근에 사용하지 않았으면, 나중에도 사용되지 않을 것이라는 아이디어에서 나옴\n\n   OPT의 경우 미래 예측이지만, LRU의 경우는 과거를 보고 판단하므로 실질적으로 사용이 가능한 알고리즘\n\n   (실제로도 최근에 사용하지 않은 페이지는 앞으로도 사용하지 않을 확률이 높다)\n\n   OPT보다는 페이지 결함이 더 일어날 수 있지만, **실제로 사용할 수 있는 페이지 교체 알고리즘에서는 가장 좋은 방법 중 하나임**\n\n   <img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FnCgc3%2FbtquGW9VUrm%2FxTKnVKPOVQuSXmAuRehSw1%2Fimg.png\">\n\n\n\n##### 교체 방식\n\n- Global 교체\n\n  > 메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식\n\n- Local 교체\n\n  > 메모리 상의 자기 프로세스 페이지에서만 교체하는 방식\n\n\n\n다중 프로그래밍의 경우, 메인 메모리에 다양한 프로세스가 동시에 올라올 수 있음\n\n따라서, 다양한 프로세스의 페이지가 메모리에 존재함\n\n페이지 교체 시, 다양한 페이지 교체 알고리즘을 활용해 victim page를 선정하는데, 선정 기준을 Global로 하느냐, Local로 하느냐에 대한 차이\n\n→ 실제로는 전체를 기준으로 페이지를 교체하는 것이 더 효율적이라고 함. 자기 프로세스 페이지에서만 교체를 하면, 교체를 해야할 때 각각 모두 교체를 진행해야 하므로 비효율적', '2022-06-07', '65');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### 메인 메모리(main memory)\n\n> 메인 메모리는 CPU가 직접 접근할 수 있는 기억 장치\n>\n> 프로세스가 실행되려면 프로그램이 메모리에 올라와야 함\n\n주소가 할당된 일련의 바이트들로 구성되어 있음\n\n<br>\n\nCPU는 레지스터가 지시하는대로 메모리에 접근하여 다음에 수행할 명령어를 가져옴\n\n명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 우선 가져와야 함\n\n이 역할을 하는 것이 바로 **MMU**.\n\n<br>\n\n#### MMU (Memory Management Unit, 메모리 관리 장치)\n\n- 논리 주소를 물리주소로 변환해 준다.\n\n- 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해주는 하드웨어임\n\n<br>\n\n메모리의 공간이 한정적이기 때문에, 사용자에게 더 많은 메모리를 제공하기 위해 \'가상 주소\'라는 개념이 등장 (가상 주소는 프로그램 상에서 사용자가 보는 주소 공간이라고 보면 됨)\n\n이 가상 주소에서 실제 데이터가 담겨 있는 곳에 접근하기 위해선 빠른 주소 변환이 필요한데, 이를 MMU가 도와주는 것\n\n즉, MMU의 역할은 다음과 같다고 말할 수 있다.\n\n> MMU가 지원되지 않으면, physical address를 직접 접근해야 하기 때문에 부담이 있다.\n>\n> MMU는 사용자가 기억장소를 일일이 할당해야 하는 불편을 없애준다.\n>\n> 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수 있게 해준다.\n\n<br>\n\n또한 메인 메모리의 직접 접근은 비효율적이므로, CPU와 메인 메모리 속도를 맞추기 위해 캐시가 존재함\n\n<br>\n\n##### MMU의 메모리 보호\n\n프로세스는 독립적인 메모리 공간을 가져야 되고, 자신의 공간만 접근해야 함\n\n따라서 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 trap을 발생시키며 보호함\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F5Lgut%2FbtquNvKMRwH%2FJOqzcmz8wiXf0Kv7okfGzK%2Fimg.png\">\n\nbase와 limit 레지스터를 활용한 메모리 보호 기법\n\nbase 레지스터는 메모리상의 프로세스 시작주소를 물리 주소로 저장\nlimit 레지스터는 프로세스의 사이즈를 저장\n\n이로써 프로세스의 접근 가능한 합법적인 메모리 영역(x)은\n\n```\nbase <= x < base+limit\n```\n\n이 영역 밖에서 접근을 요구하면 trap을 발생시키는 것\n\n<br>\n\n안전성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계 (사용자 모드에서는 직접 변경할 수 없도록)\n\n<br>\n\n<br>\n\n##### 메모리 과할당(over allocating)\n\n> 실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황\n\n<br>\n\n페이지 기법과 같은 메모리 관리 기법은 사용자가 눈치 채지 못하도록 눈속임을 통해 메모리를 할당해줌 (가상 메모리를 이용해서)\n\n<br>\n\n과할당 상황에 대해서 사용자를 속인 것을 들킬만한 상황이 존재함\n\n1. 프로세스 실행 도중 페이지 폴트 발생\n2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음\n3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음\n\n<br>\n\n이러한 과할당을 해결하기 위해선, 빈 프레임을 확보할 수 있어야 함\n\n1. 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임을 얻음\n\n2. 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용\n\n<br>\n\nswapping 기법을 통해 공간을 바꿔치기하는 2번 방법과는 달리 1번은 사용자에게 페이징 시스템을 들킬 가능성이 매우 높아서 하면 안됨\n\n(페이징 기법은 사용자 모르게 시스템 능률을 높이기 위해 선택한 일이므로 들키지 않게 처리해야한다)\n\n<br>\n\n따라서, 2번과 같은 해결책을 통해 페이지 교체가 이루어져야 함\n\n<br>\n\n<br>\n\n#####  페이지 교체\n\n> 메모리 과할당이 발생했을 때, 프로세스 하나를 swap out해서 빈 프레임을 확보하는 것\n\n<br>\n\n1. 프로세스 실행 도중 페이지 부재 발생\n\n2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음\n\n3. 메모리에 빈 프레임이 있는지 확인\n\n   > 빈 프레임이 있으면 해당 프레임을 사용\n   >\n   > 빈 프레임이 없으면, victim 프레임을 선정해 디스크에 기록하고 페이지 테이블을 업데이트함\n\n4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트\n\n<br>\n\n페이지 교체가 이루어지면 아무일이 없던것 처럼 프로세스를 계속 수행시켜주면서 사용자가 알지 못하도록 해야 함\n\n이때, 아무일도 일어나지 않은 것처럼 하려면, 페이지 교체 당시 오버헤드를 최대한 줄여야 함\n\n<br>\n\n##### 오버헤드를 감소시키는 해결법\n\n이처럼 빈 프레임이 없는 상황에서 victim 프레임을 비울 때와 원하는 페이지를 프레임으로 올릴 때 두 번의 디스크 접근이 이루어짐\n\n페이지 교체가 많이 이루어지면, 이처럼 입출력 연산이 많이 발생하게 되면서 오버헤드 문제가 발생함\n\n<br>\n\n##### 방법1\n\n변경비트를 모든 페이지마다 둬서, victim 페이지가 정해지면 해당 페이지의 비트를 확인\n\n해당 비트가 set 상태면? → 해당 페이지 내용이 디스크 상의 페이지 내용과 달라졌다는 뜻\n(즉, 페이지가 메모리 올라온 이후 한번이라도 수정이 일어났던 것. 따라서 이건 디스크에 기록해야함)\n\nbit가 clear 상태라면? → 디스크 상의 페이지 내용과 메모리 상의 페이지가 정확히 일치하는 상황\n(즉, 디스크와 내용이 같아서 기록할 필요가 없음)\n\n비트를 활용해  디스크에 기록하는 횟수를 줄이면서 오버헤드에 대한 수를 최대 절반으로 감소시키는 방법임\n\n<br>\n\n##### 방법2\n\n페이지 교체 알고리즘을 상황에 따라 잘 선택해야 함\n\n현재 상황에서 페이지 폴트를 발생할 확률을 최대한 줄여줄 수 있는 교체 알고리즘을 사용\n\nFIFO\n\nOPT\n\nLRU\n\n<br>\n\n<br>\n\n#### 캐시 메모리\n\n> 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치\n>\n> CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위한 방법\n\nCPU가 이미 봤던걸 다시 재접근할 때, 메모리 참조 및 인출 과정에 대한 비용을 줄이기 위해 캐시에 저장해둔 데이터를 활용한다\n\n캐시는 플리플롭 소자로 구성되어 SRAM으로 되어있어서 DRAM보다 빠른 장점을 지님\n\n<br>\n\n##### CPU와 기억장치의 상호작용\n\nCPU에서 주소를 전달 → 캐시 기억장치에 명령이 존재하는지 확인\n\n(존재) Hit\n\n해당 명령어를 CPU로 전송 → 완료\n\n(비존재) Miss\n\n명령어를 갖고 주기억장치로 접근 → 해당 명령어를 가진 데이터 인출 → 해당 명령어 데이터를 캐시에 저장 → 해당 명령어를 CPU로 전송 → 완료\n\n<br>\n\n이처럼 캐시를 잘 활용한다면 비용을 많이 줄일 수 있음\n\n따라서 CPU가 어떤 데이터를 원할지 어느정도 예측할 수 있어야 함\n\n(캐시에 많이 활용되는 쓸모 있는 정보가 들어있어야 성능이 높아짐)\n\n<br>\n\n적중률을 극대화시키기 위해 사용되는 것이 바로 `지역성의 원리`\n\n##### 지역성\n\n> 기억 장치 내의 정보를 균일하게 액세스 하는 것이 아니라 한 순간에 특정부분을 집중적으로 참조하는 특성\n\n<br>\n\n지역성의 종류는 시간과 공간으로 나누어짐\n\n**시간 지역성** : 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성\n\n**공간 지역성** : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성\n\n<br>\n\n<br>\n\n#### 캐싱 라인\n\n빈번하게 사용되는 데이터들을 캐시에 저장했더라도, 내가 필요한 데이터를 캐시에서 찾을 때 모든 데이터를 순회하는 것은 시간 낭비다.\n\n즉, 캐시에 목적 데이터가 저장되어있을 때 바로 접근하여 출력할 수 있어야 캐시 활용이 의미있어짐\n\n따라서 캐시에 데이터를 저장할 시, 자료구조를 활용해 묶어서 저장하는데 이를 `캐싱 라인`이라고 부른다.\n\n즉, 캐시에 저장하는 데이터에 데이터의 메모리 주소를 함께 저장하면서 빠르게 원하는 정보를 찾을 수 있음 (set이나 map 등을 활용) ', '2022-06-07', '66');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 파일 시스템(File System)\n\n<br>\n\n컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법이다.\n\n저장매체에는 수많은 파일이 있기 때문에, 이런 파일들을 관리하는 방법을 말한다.\n\n##### <br>\n\n##### 특징\n\n- 커널 영역에서 동작\n- 파일 CRUD 기능을 원활히 수행하기 위한 목적\n\n- 계층적 디렉터리 구조를 가짐\n- 디스크 파티션 별로 하나씩 둘 수 있음\n\n##### 역할\n\n- 파일 관리\n- 보조 저장소 관리\n- 파일 무결성 메커니즘\n- 접근 방법 제공\n\n##### 개발 목적\n\n- 하드디스크와 메인 메모리 속도차를 줄이기 위함\n- 파일 관리\n- 하드디스크 용량 효율적 이용\n\n##### 구조\n\n- 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 정보\n- 데이터 영역 : 파일의 데이터\n\n<br>\n\n<br>\n\n#### 접근 방법\n\n1. ##### 순차 접근(Sequential Access)\n\n   > 가장 간단한 접근 방법으로, 대부분 연산은 read와 write\n\n   <img src=\"https://noep.github.io/2016/02/23/10th-filesystem/10.1.png\">\n\n   현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write를 진행. 뒤로 돌아갈 땐 지정한 offset만큼 되감기를 해야 한다. (테이프 모델 기반)\n\n2. ##### 직접 접근(Direct Access)\n\n   > 특별한 순서없이, 빠르게 레코드를 read, write 가능\n\n   <img src=\"https://noep.github.io/2016/02/23/10th-filesystem/10.2.png\">\n\n   현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현이 가능하다.\n\n   무작위 파일 블록에 대한 임의 접근을 허용한다. 따라서 순서의 제약이 없음\n\n   대규모 정보를 접근할 때 유용하기 때문에 \'데이터베이스\'에 활용된다.\n\n3. 기타 접근\n\n   > 직접 접근 파일에 기반하여 색인 구축\n\n   <img src=\"https://noep.github.io/2016/02/23/10th-filesystem/10.3.png\">\n\n   크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법임\n\n<br>\n\n<br>\n\n### 디렉터리와 디스크 구조\n\n---\n\n- ##### 1단계 디렉터리\n\n  > 가장 간단한 구조\n\n  파일들은 서로 유일한 이름을 가짐. 서로 다른 사용자라도 같은 이름 사용 불가\n\n  <img src=\"https://noep.github.io/2016/02/23/10th-filesystem/10.5.png\">\n\n- ##### 2단계 디렉터리\n\n  > 사용자에게 개별적인 디렉터리 만들어줌\n\n  - UFD : 자신만의 사용자 파일 디렉터리\n  - MFD : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리\n\n  <img src=\"https://noep.github.io/2016/02/23/10th-filesystem/10.6.png\">\n\n- ##### 트리 구조 디렉터리\n\n  > 2단계 구조 확장된 다단계 트리 구조\n\n  한 비트를 활용하여, 일반 파일(0)인지 디렉터리 파일(1) 구분\n\n  <img src=\"https://noep.github.io/2016/02/23/10th-filesystem/10.7.png\">\n\n- 그래프 구조 디렉터리\n\n  > 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나, 가비지 컬렉션을 이용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시\n\n  링크가 있으면 우회하여 순환을 피할 수 있음\n\n  <img src=\"https://noep.github.io/2016/02/23/10th-filesystem/10.9.png\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n##### [참고 자료]\n\n- [링크]( https://noep.github.io/2016/02/23/10th-filesystem/ )', '2022-06-07', '67');
insert into cscontent (cs_content, cs_regdate, cs_code) values('### [Design Pattern] 개요\n\n---\n\n> 일종의 설계 기법이며, 설계 방법이다.\n\n\n\n* #### 목적\n\n  SW **재사용성, 호환성, 유지 보수성**을 보장.\n\n  <br>\n\n* #### 특징\n\n  **디자인 패턴은 아이디어**임, 특정한 구현이 아님.\n\n  프로젝트에 항상 적용해야 하는 것은 아니지만, 추후 재사용, 호환, 유지 보수시 발생하는 **문제 해결을 예방하기 위해 패턴을 만들어 둔 것**임.\n\n  <br>\n\n* #### 원칙\n\n  ##### SOLID (객체지향 설계 원칙)\n\n  (간략한 설명)\n\n  1. ##### Single Responsibility Principle\n\n     > 하나의 클래스는 하나의 역할만 해야 함.\n\n  2. ##### Open - Close Principle\n\n     > 확장 (상속)에는 열려있고, 수정에는 닫혀 있어야 함.\n\n  3. ##### Liskov Substitution Principle\n\n     > 자식이 부모의 자리에 항상 교체될 수 있어야 함.\n\n  4. ##### Interface Segregation Principle\n\n     > 인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야함.\n\n  5. ##### Dependency Inversion Property\n\n     > 상위 모듈이 하위 모듈에 의존하면 안됨.\n     >\n     > 둘 다 추상화에 의존하며, 추상화는 세부 사항에 의존하면 안됨.\n\n<br>\n\n* #### 분류 (중요)\n\n`3가지 패턴의 목적을 이해하기!`\n\n1. 생성 패턴 (Creational) : 객체의 **생성 방식** 결정\n\n   Class-creational patterns, Object-creational patterns.\n\n   ```text\n   예) DBConnection을 관리하는 Instance를 하나만 만들 수 있도록 제한하여, 불필요한 연결을 막음.\n   ```\n\n   <br>\n\n2. 구조 패턴 (Structural) : 객체간의 **관계**를 조직\n\n   ```text\n   예) 2개의 인터페이스가 서로 호환이 되지 않을 때, 둘을 연결해주기 위해서 새로운 클래스를 만들어서 연결시킬 수 있도록 함.\n   ```\n\n   <br>\n\n3. 행위 패턴 (Behavioral): 객체의 **행위**를 조직, 관리, 연합\n\n   ```text\n   예) 하위 클래스에서 구현해야 하는 함수 및 알고리즘들을 미리 선언하여, 상속시 이를 필수로 구현하도록 함.\n   ```\n\n<br>\n', '2022-06-07', '68');
insert into cscontent (cs_content, cs_regdate, cs_code) values('### 어댑터 패턴\n\n---\n\n> - 용도 : 클래스를 바로 사용할 수 없는 경우가 있음 (다른 곳에서 개발했다거나, 수정할 수 없을 때)\n>   중간에서 변환 역할을 해주는 클래스가 필요 → 어댑터 패턴\n>\n> - 사용 방법 : 상속\n> - 호환되지 않은 인터페이스를 사용하는 클라이언트 그대로 활용 가능\n>\n> - 향후 인터페이스가 바뀌더라도, 변경 내역은 어댑터에 캡슐화 되므로 클라이언트 바뀔 필요X\n\n\n\n<br>\n\n##### 클래스 다이어그램\n\n![img](https://t1.daumcdn.net/cfile/tistory/99D2F0445C6A152229)\n\n\n\n아이폰의 이어폰을 생각해보자\n\n가장 흔한 이어폰 잭을 아이폰에 사용하려면, 잭 자체가 맞지 않는다.\n\n따라서 우리는 어댑터를 따로 구매해서 연결해야 이런 이어폰들을 사용할 수 있다\n\n\n\n이처럼 **어댑터는 필요로 하는 인터페이스로 바꿔주는 역할**을 한다\n\n\n\n\n\n![img](https://t1.daumcdn.net/cfile/tistory/99F3134C5C6A152D31)\n\n이처럼 업체에서 제공한 클래스가 기존 시스템에 맞지 않으면?\n\n> 기존 시스템을 수정할 것이 아니라, 어댑터를 활용해 유연하게 해결하자\n\n\n\n<br>\n\n##### 코드로 어댑터 패턴 이해하기\n\n> 오리와 칠면조 인터페이스 생성\n>\n> 만약 오리 객체가 부족해서 칠면조 객체를 대신 사용해야 한다면?\n>\n> 두 객체는 인터페이스가 다르므로, 바로 칠면조 객체를 사용하는 것은 불가능함\n>\n> 따라서 칠면조 어댑터를 생성해서 활용해야 한다\n\n\n\n- Duck.java\n\n```java\npackage AdapterPattern;\n\npublic interface Duck {\n	public void quack();\n	public void fly();\n}\n```\n\n\n\n- Turkey.java\n\n```java\npackage AdapterPattern;\n\npublic interface Turkey {\n	public void gobble();\n	public void fly();\n}\n```\n\n\n\n-  WildTurkey.java\n\n```java\npackage AdapterPattern;\n\npublic class WildTurkey implements Turkey {\n\n	@Override\n	public void gobble() {\n		System.out.println(\"Gobble gobble\");\n	}\n\n	@Override\n	public void fly() {\n		System.out.println(\"I\'m flying a short distance\");\n	}\n}\n```\n\n- TurkeyAdapter.java\n\n```java\npackage AdapterPattern;\n\npublic class TurkeyAdapter implements Duck {\n\n	Turkey turkey;\n\n	public TurkeyAdapter(Turkey turkey) {\n		this.turkey = turkey;\n	}\n\n	@Override\n	public void quack() {\n		turkey.gobble();\n	}\n\n	@Override\n	public void fly() {\n		turkey.fly();\n	}\n\n}\n```\n\n- DuckTest.java\n\n```java\npackage AdapterPattern;\n\npublic class DuckTest {\n\n	public static void main(String[] args) {\n\n		MallardDuck duck = new MallardDuck();\n		WildTurkey turkey = new WildTurkey();\n		Duck turkeyAdapter = new TurkeyAdapter(turkey);\n\n		System.out.println(\"The turkey says...\");\n		turkey.gobble();\n		turkey.fly();\n\n		System.out.println(\"The Duck says...\");\n		testDuck(duck);\n\n		System.out.println(\"The TurkeyAdapter says...\");\n		testDuck(turkeyAdapter);\n\n	}\n\n	public static void testDuck(Duck duck) {\n\n		duck.quack();\n		duck.fly();\n\n	}\n}\n```\n아까 확인한 클래스 다이어그램에서 Target은 오리에 해당하며, Adapter는 칠면조라고 생각하면 된다.\n', '2022-06-07', '69');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## [디자인 패턴] 싱글톤 패턴(Singleton pattern)\n\n<br>\n\n##### *싱글톤 패턴이란?*\n\n애플리케이션이 시작될 때, 어떤 클래스가 최초 한 번만 메모리를 할당(static)하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴\n\n<br>\n\n즉, 싱글톤 패턴은 \'하나\'의 인스턴스만 생성하여 사용하는 디자인 패턴이다.\n\n> 인스턴스가 필요할 때, 똑같은 인스턴스를 만들지 않고 기존의 인스턴스를 활용하는 것!\n\n<br>\n\n생성자가 여러번 호출되도, 실제로 생성되는 객체는 하나이며 최초로 생성된 이후에 호출된 생성자는 이미 생성한 객체를 반환시키도록 만드는 것이다\n\n(java에서는 생성자를 private으로 선언해 다른 곳에서 생성하지 못하도록 만들고, getInstance() 메소드를 통해 받아서 사용하도록 구현한다)\n\n<br>\n\n##### *왜 쓰나요?*\n\n먼저, 객체를 생성할 때마다 메모리 영역을 할당받아야 한다. 하지만 한번의 new를 통해 객체를 생성한다면 메모리 낭비를 방지할 수 있다.\n\n또한 싱글톤으로 구현한 인스턴스는 \'전역\'이므로, 다른 클래스의 인스턴스들이 데이터를 공유하는 것이 가능한 장점이 있다.\n\n<br>\n\n##### *많이 사용하는 경우가 언제인가요?*\n\n주로 공통된 객체를 여러개 생성해서 사용해야하는 상황\n\n```\n데이터베이스에서 커넥션풀, 스레드풀, 캐시, 로그 기록 객체 등\n```\n\n안드로이드 앱 : 각 액티비티 들이나, 클래스마다 주요 클래스들을 하나하나 전달하는게 번거롭기 때문에 싱글톤 클래스를 만들어 어디서든 접근하도록 설계\n\n또한 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 때 사용함\n\n<br>\n\n##### *단점도 있나요?*\n\n객체 지향 설계 원칙 중에 `개방-폐쇄 원칙`이란 것이 존재한다.\n\n만약 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유시키면 다른 클래스들 간의 결합도가 높아지게 되는데, 이때 개방-폐쇄 원칙이 위배된다.\n\n결합도가 높아지게 되면, 유지보수가 힘들고 테스트도 원활하게 진행할 수 없는 문제점이 발생한다.\n\n<br>\n\n또한, 멀티 스레드 환경에서 동기화 처리를 하지 않았을 때, 인스턴스가 2개가 생성되는 문제도 발생할 수 있다.\n\n<br>\n\n따라서, 반드시 싱글톤이 필요한 상황이 아니면 지양하는 것이 좋다고 한다. (설계 자체에서 싱글톤 활용을 원활하게 할 자신이 있으면 괜찮음)\n\n<br>\n\n<br>\n\n#### 멀티스레드 환경에서 안전한 싱글톤 만드는 법\n\n---\n\n1. #####  Lazy Initialization (초기화 지연)\n\n   ```java\n   public class ThreadSafe_Lazy_Initialization{\n    \n       private static ThreadSafe_Lazy_Initialization instance;\n    \n       private ThreadSafe_Lazy_Initialization(){}\n        \n       public static synchronized ThreadSafe_Lazy_Initialization getInstance(){\n           if(instance == null){\n               instance = new ThreadSafe_Lazy_Initialization();\n           }\n           return instance;\n       }\n    \n   }\n   ```\n\n   private static으로 인스턴스 변수 만듬\n\n   private으로 생성자를 만들어 외부에서의 생성을 막음\n\n   synchronized 동기화를 활용해 스레드를 안전하게 만듬\n\n   > 하지만, synchronized는 큰 성능저하를 발생시키므로 권장하지 않는 방법\n\n   <br>\n\n2. ##### Lazy Initialization + Double-checked Locking\n\n   > 1번의 성능저하를 완화시키는 방법\n\n   ```java\n   public class ThreadSafe_Lazy_Initialization{\n       private volatile static ThreadSafe_Lazy_Initialization instance;\n   \n       private ThreadSafe_Lazy_Initialization(){}\n   \n       public static ThreadSafe_Lazy_Initialization getInstance(){\n       	if(instance == null) {\n           	synchronized (ThreadSafe_Lazy_Initialization.class){\n                   if(instance == null){\n                       instance = new ThreadSafe_Lazy_Initialization();\n                   }\n               }\n           }\n           return instance;\n       }\n   }\n   ```\n\n   1번과는 달리, 먼저 조건문으로 인스턴스의 존재 여부를 확인한 다음 두번째 조건문에서 synchronized를 통해 동기화를 시켜 인스턴스를 생성하는 방법\n\n   스레드를 안전하게 만들면서, 처음 생성  이후에는 synchronized를 실행하지 않기 때문에 성능저하 완화가 가능함\n\n   > 하지만 완전히 완벽한 방법은 아님\n\n   <br>\n\n3. #####  Initialization on demand holder idiom (holder에 의한 초기화)\n\n   클래스 안에 클래스(holder)를 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방법\n\n   ```java\n   public class Something {\n       private Something() {\n       }\n    \n       private static class LazyHolder {\n           public static final Something INSTANCE = new Something();\n       }\n    \n       public static Something getInstance() {\n           return LazyHolder.INSTANCE;\n       }\n   }\n   ```\n\n   2번처럼 동기화를 사용하지 않는 방법을 안하는 이유는, 개발자가 직접 동기화 문제에 대한 코드를 작성하면서 회피하려고 하면 프로그램 구조가 그만큼 복잡해지고 비용 문제가 발생할 수 있음. 또한 코드 자체가 정확하지 못할 때도 많음\n\n   <br>\n\n\n   이 때문에, 3번과 같은 방식으로 JVM의 클래스 초기화 과정에서 보장되는 `원자적 특성`을 이용해 싱글톤의 초기화 문제에 대한 책임을 JVM에게 떠넘기는 걸 활용함\n\n   <br>\n\n   클래스 안에 선언한 클래스인 holder에서 선언된 인스턴스는 static이기 때문에 클래스 로딩시점에서 한번만 호출된다. 또한 final을 사용해서 다시 값이 할당되지 않도록 만드는 방식을 사용한 것\n\n   > 실제로 가장 많이 사용되는 일반적인 싱글톤 클래스 사용 방법이 3번이다.', '2022-06-07', '70');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### 디자인 패턴 _ Template Method Pattern\n\n---\n\n[디자인 패턴 예]\n\n1. 템플릿 메서드 패턴\n\n   특정 환경 or 상황에 맞게 확장, 변경할 때 유용한 패턴\n\n   **<u>추상 클래스, 구현 클래스</u>** 둘로 구분. \n\n   추상클래스 (Abstract Class) : 메인이 되는 로직 부분은 일반 메소드로 선언해 둠.\n\n   구현클래스 (Concrete Class) : 메소드를 선언 후 호출하는 방식.\n\n   - 장점\n     - 구현 클래스에서는 추상 클래스에 선언된 메소드만 사용하므로, **<u>핵심 로직 관리가 용이</u>**\n     - 객체 추가 및 확장 가능\n   - 단점\n     - 추상 메소드가 많아지면, 클래스 관리가 복잡함.\n\n   * 설명\n\n     1) HouseTemplate.java\n\n     > Template 추상 클래스를 하나 생성. (예, HouseTemplate)\n     >\n     > 이 HouseTemplate을 사용할 때는,\n     >\n     > \"HouseTemplate houseType = new WoodenHouse()\" 이런 식으로 넣음.\n     >\n     > HouseTemplate 내부에 **<u>buildHouse</u>**라는 변해서는 안되는 핵심 로직을 만들어 놓음. (장점 1)\n     >\n     > Template 클래스 내부의 **<u>핵심 로직 내부의 함수</u>**를 상속하는 클래스가 직접 구현하도록, abstract를 지정해 둠.\n\n     ```java\n     public abstract class HouseTemplate {\n         \n         // 이런 식으로 buildHouse라는 함수 (핵심 로직)을 선언해 둠.\n         public final void buildHouse() {\n             buildFoundation();	// (1)\n             buildPillars();		// (2)\n             buildWalls();		// (3)\n             buildWindows();		// (4)\n             System.out.println(\"House is built.\");\n         }\n         \n         // buildFoundation(); 정의 부분 (1)\n         // buildWalls(); 정의 부분		(2)\n         \n         // 위의 두 함수와는 다르게 이 클래스를 상속받는 클래스가 별도로 구현했으면 하는 메소드들은 abstract로 선언하여, 정의하도록 함\n         public abstract void buildWalls();	// (3)\n         public abstract void buildPillars();// (4)\n         \n     }\n     \n     ```\n\n     \n\n     2) WoodenHouse.java (GlassHouse.java도 가능)\n\n     > HouseTemplate을 상속받는 클래스.\n     >\n     > Wooden이나, Glass에 따라서 buildHouse 내부의 핵심 로직이 바뀔 수 있으므로,\n     >\n     > 이 부분을 반드시 선언하도록 지정해둠.\n\n     ```java\n     public class WoodenHouse extends HouseTemplate {\n         @Override\n         public void buildWalls() {\n             System.out.println(\"Building Wooden Walls\");\n         }\n         @Override\n         public void buildPillars() {\n             System.out.println(\"Building Pillars with Wood coating\");\n         }\n     }\n     ```\n\n     ', '2022-06-07', '71');
insert into cscontent (cs_content, cs_regdate, cs_code) values('#### Design Pattern - Factory Method Pattern\n\n---\n\n한 줄 설명 : 객체를 만드는 부분을 Sub class에 맡기는 패턴.\n\n> Robot (추상 클래스)\n>\n> ​	ㄴ SuperRobot\n>\n> ​	ㄴ PowerRobot\n>\n> RobotFactory (추상 클래스)\n>\n> ​	ㄴ SuperRobotFactory\n>\n> ​	ㄴ ModifiedSuperRobotFactory\n\n즉 Robot이라는 클래스를 RobotFactory에서 생성함.\n\n- RobotFactory 클래스 생성\n\n```java\npublic abstract class RobotFactory {\n	abstract Robot createRobot(String name);\n}\n```\n\n* SuperRobotFactory 클래스 생성\n\n```java\npublic class SuperRobotFactory extends RobotFactory {\n	@Override\n	Robot createRobot(String name) {\n		switch(name) {\n		case \"super\" :\n			return new SuperRobot();\n		case \"power\" :\n			return new PowerRobot();\n		}\n		return null;\n	}\n}\n```\n\n생성하는 클래스를 따로 만듬...\n\n그 클래스는 factory 클래스를 상속하고 있기 때문에, 반드시 createRobot을 선언해야 함.\n\nname으로 건너오는 값에 따라서, 생성되는 Robot이 다르게 설계됨.\n\n---\n\n정리하면, 생성하는 객체를 별도로 둔다. 그리고, 그 객체에 넘어오는 값에 따라서, 다른 로봇 (피자)를 만들어 낸다.\n', '2022-06-07', '72');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 옵저버 패턴(Observer pattern)\n\n> 상태를 가지고 있는 주체 객체 & 상태의 변경을 알아야 하는 관찰 객체\n\n(1 대 1 or 1 대 N 관계)\n\n서로의 정보를 주고받는 과정에서 정보의 단위가 클수록, 객체들의 규모가 클수록 복잡성이 증가하게 된다. 이때 가이드라인을 제시해줄 수 있는 것이 \'옵저버 패턴\'\n\n<br>\n\n##### 주체 객체와 관찰 객체의 예는?\n\n```\n잡지사 : 구독자\n우유배달업체 : 고객\n```\n\n구독자, 고객들은 정보를 얻거나 받아야 하는 주체와 관계를 형성하게 된다. 관계가 지속되다가 정보를 원하지 않으면 해제할 수도 있다. (잡지 구독을 취소하거나 우유 배달을 중지하는 것처럼)\n\n> 이때, 객체와의 관계를 맺고 끊는 상태 변경 정보를 Observer에 알려줘서 관리하는 것을 말한다.\n\n<br>\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2214233B56A4D98611449A\">\n\n- ##### Publisher 인터페이스\n\n  > Observer들을 관리하는 메소드를 가지고 있음\n  >\n  > 옵저버 등록(add), 제외(delete), 옵저버들에게 정보를 알려줌(notifyObserver)\n\n  ```java\n  public interface Publisher { \n      public void add(Observer observer); \n      public void delete(Observer observer); \n      public void notifyObserver(); \n  }\n  ```\n\n  <br>\n\n- ##### Observer 인터페이스\n\n  > 정보를 업데이트(update)\n\n  ```java\n  public interface Observer { \n      public void update(String title, String news); }\n  ```\n\n  <br>\n\n- ##### NewsMachine 클래스\n\n  > Publisher를 구현한 클래스로, 정보를 제공해주는 퍼블리셔가 됨\n\n  ```java\n  public class NewsMachine implements Publisher {\n      private ArrayList<Observer> observers; \n      private String title; \n      private String news; \n  \n      public NewsMachine() {\n          observers = new ArrayList<>(); \n      }\n      \n      @Override public void add(Observer observer) {\n          observers.add(observer);\n      }\n      \n      @Override public void delete(Observer observer) 	{ \n          int index = observers.indexOf(observer);\n          observers.remove(index); \n      }\n      \n      @Override public void notifyObserver() {\n          for(Observer observer : observers) {\n             observer.update(title, news); \n          }\n      } \n      \n      public void setNewsInfo(String title, String news) { \n          this.title = title; \n          this.news = news; \n          notifyObserver(); \n      } \n      \n      public String getTitle() { return title; } 		public String getNews() { return news; }\n  }\n  ```\n\n  <br>\n\n- ##### AnnualSubscriber, EventSubscriber 클래스\n\n  > Observer를 구현한 클래스들로, notifyObserver()를 호출하면서 알려줄 때마다 Update가 호출됨\n\n  ```java\n  public class EventSubscriber implements Observer {\n      \n      private String newsString;\n      private Publisher publisher;\n      \n      public EventSubscriber(Publisher publisher) {\n          this.publisher = publisher;\n          publisher.add(this);\n      }\n      \n      @Override\n      public void update(String title, String news) {\n          newsString = title + \" \" + news;\n          display();\n      }\n      \n      public void withdraw() {\n          publisher.delete(this);\n      }\n      \n      public void display() {\n          System.out.println(\"이벤트 유저\");\n          System.out.println(newsString);\n      }\n      \n  }\n  ```\n\n  <br>\n\n<br>\n\nJava에는 옵저버 패턴을 적용한 것들을 기본적으로 제공해줌\n\n> Observer 인터페이스, Observable 클래스\n\n하지만 Observable은 클래스로 구현되어 있기 때문에 사용하려면 상속을 해야 함. 따라서 다른 상속을 함께 이용할 수 없는 단점 존재\n\n<br>\n\n<br>\n\n#### 정리\n\n> 옵저버 패턴은, 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고, 자동으로 정보가 갱신되는 1:N 관계(혹은 1대1)를 정의한다.\n>\n> 인터페이스를 통해 연결하여 느슨한 결합성을 유지하며, Publisher와 Observer 인터페이스를 적용한다.\n>\n> 안드로이드 개발시, OnClickListener와 같은 것들이 옵저버 패턴이 적용된 것 (버튼(Publisher)을 클릭했을 때 상태 변화를 옵저버인 OnClickListener로 알려주로독 함)\n\n<br>\n\n##### [참고]\n\n[링크](<https://flowarc.tistory.com/entry/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4Observer-Pattern>)', '2022-06-07', '73');
insert into cscontent (cs_content, cs_regdate, cs_code) values('## 스트레티지 패턴(Strategy Pattern)\n\n> 어떤 동작을 하는 로직을 정의하고, 이것들을 하나로 묶어(캡슐화) 관리하는 패턴\n\n새로운 로직을 추가하거나 변경할 때, 한번에 효율적으로 변경이 가능하다.\n\n<br>\n\n```\n[ 슈팅 게임을 설계하시오 ]\n유닛 종류 : 전투기, 헬리콥터\n유닛들은 미사일을 발사할 수 있다.\n전투기는 직선 미사일을, 헬리콥터는 유도 미사일을 발사한다.\n필살기로는 폭탄이 있는데, 전투기에는 있고 헬리콥터에는 없다.\n```\n\n<br>\n\nStrategy pattern을 적용한 설계는 아래와 같다.\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F255CF641559E74AC09EFBB\">\n\n> 상속은 무분별한 소스 중복이 일어날 수 있으므로, 컴포지션을 활용한다. (인터페이스와 로직의 클래스와의 관계를 컴포지션하고, 유닛에서 상황에 맞는 로직을 쓰게끔 유도하는 것)\n\n<br>\n\n- ##### 미사일을 쏘는 것과 폭탄을 사용하는 것을 캡슐화하자\n\n  ShootAction과 BombAction으로 인터페이스를 선언하고, 각자 필요한 로직을 클래스로 만들어 implement한다.\n\n- ##### 전투기와 헬리콥터를 묶을 Unit 추상 클래스를 만들자\n\n  Unit에는 공통적으로 사용되는 메서드들이 들어있고, 미사일과 폭탄을 선언하기 위해 variable로 인터페이스들을 선언한다.\n\n<br>\n\n전투기와 헬리콥터는 Unit 클래스를 상속받고, 생성자에 맞는 로직을 정의해주면 끝난다.\n\n##### 전투기 예시\n\n```java\nclass Fighter extends Unit {\n    private ShootAction shootAction;\n    private BombAction bombAction;\n    \n    public Fighter() {\n        shootAction = new OneWayMissle();\n        bombAction = new SpreadBomb();\n    }\n}\n```\n\n`Fighter.doAttack()`을 호출하면, OneWayMissle의 attack()이 호출될 것이다.\n\n<br>\n\n#### 정리\n\n이처럼 Strategy Pattern을 활용하면 로직을 독립적으로 관리하는 것이 편해진다. 로직에 들어가는 \'행동\'을 클래스로 선언하고, 인터페이스와 연결하는 방식으로 구성하는 것!\n\n<br>\n\n<br>\n\n##### [참고]\n\n[링크](<https://flowarc.tistory.com/entry/1-Strategy-Pattern?category=562154>)\n', '2022-06-07', '74');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# Composite Pattern\n\n### 목적\ncompositie pattern의 사용 목적은 object의 **hierarchies**를 표현하고 각각의 object를 독립적으로 동일한 인터페이스를 통해 처리할 수 있게한다.\n\n아래 Composite pattern의 class diagram을 보자\n\n![composite pattenr](../resources/composite_pattern_1.PNG)\n\n위의 그림의 Leaf 클래스와 Composite 클래스를 같은 interface로 제어하기 위해서 Component abstract 클래스를 생성하였다.\n\n위의 그림을 코드로 표현 하였다.\n\n**Component 클래스**\n```java\npublic class Component {\n    public void operation() {\n        throw new UnsupportedOperationException();\n    }\n    public void add(Component component) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void remove(Component component) {\n        throw new UnsupportedOperationException();\n    }\n\n    public Component getChild(int i) {\n        throw new UnsupportedOperationException();\n    }\n}\n```\nLeaf 클래스와 Compositie 클래스가 상속하는 Component 클래스로 Leaf 클래스에서 사용하지 않는 메소드 호출 시 exception을 발생시키게 구현하였다.\n\n**Leaf 클래스**\n```java\npublic class Leaf extends Component {\n    String name;\n    public Leaf(String name) {\n        ...\n    }\n\n    public void operation() {\n        .. something ...\n    }\n}\n```\n\n**Composite class**\n```java\npublic class Composite extends Component {\n    ArrayList components = new ArrayList();\n    String name;\n\n    public Composite(String name) {\n        ....\n    }\n\n    public void operation() {\n        Iterator iter = components.iterator();\n        while (iter.hasNext()) {\n            Component component = (Component)iter.next();\n            component.operation();\n        }\n    }\n    public void add(Component component) {\n        components.add(component);\n    }\n\n    public void remove(Component component) {\n        components.remove(component);\n    }\n\n    public Component getChild(int i) {\n        return (Component)components.get(i);\n    }\n}\n```\n\n## 구현 시 고려해야할 사항\n- 위의 코드는 parent만이 child를 참조할 수 있다. 구현 이전에 child가 parent를 참조해야 하는지 고려해야 한다.\n- 어떤 클래스가 children을 관리할 것인가?\n\n## Children 관리를 위한 2가지 Composite pattern\n![composite pattenr](../resources/composite_pattern_1.PNG)\n\n위의 예제로 Component 클래스에 add, removem getChild 같은 method가 선언이 되어있으며 Transparency를 제공한다.\n\n장점 : Leaf 클래스와 Composite 클래스를 구분할 필요없이 Component Class로 생각할 수 있다.\n\n단점 : Leaf 클래스가 chidren 관리 함수 호출 시 run time에 exception이 발생한다.\n\n![composite pattenr](../resources/composite_pattern_2.PNG)\n\n이전 예제에서 children을 관리하는 함수를 Composite 클래스에 선언 되어있으며 Safety를 제공한다.\n\n장점 : Leaf 클래스가 chidren 관리 함수 호출 시 compile time에 문제를 확인할 수 있다.\n\n단점 : Leaf 클래스와 Composite 클래스를 구분하여야 한다.\n\n## 관련 패턴\n### Decorator\n공통점 : composition이 재귀적으로 발생한다.\n\n차이점 : decorator 패턴은 responsibilites를 추가하는 것이 목표이지만 composite 패턴은 hierarchy를 표현하기 위해서 사용된다.\n\n### Iterator\n공통점 : aggregate object을 순차적으로 접근한다.', '2022-06-07', '75');
insert into cscontent (cs_content, cs_regdate, cs_code) values('# An overview of design pattern - SOLID, GRASP\n\n먼저 디자인 패턴을 공부하기 전에 Design Principle인 SOLID와 GRASP에 대해서 알아보자\n\n\n# Design Smells\ndesign smell이란 나쁜 디자인을 나타내는 증상같은 것이다.\n\n아래 4가지 종류가 있다.\n1. Rigidity(경직성)  \n    시스템이 변경하기 어렵다. 하나의 변경을 위해서 다른 것들을 변경 해야할 때 경직성이 높다.\n    경직성이 높다면 non-critical한 문제가 발생했을 때 관리자는 개발자에게 수정을 요청하기가 두려워진다. \n\n2. Fragility(취약성)  \n    취약성이 높다면 시스템은 어떤 부분을 수정하였는데 관련이 없는 다른 부분에 영향을 준다. 수정사항이 관련되지 않은 부분에도 영향을 끼치기 떄문에 관리하는 비용이 커지며 시스템의 credibility 또한 잃는다.\n\n3. Immobility(부동성)  \n    부동성이 높다면 재사용하기 위해서 시스템을 분리해서 컴포넌트를 만드는 것이 어렵다. 주로 개발자가 이전에 구현되었던 모듈과 비슷한 기능을 하는 모듈을 만들려고 할 때 문제점을 발견한다.\n\n4. Viscosity(점착성)  \n    점착성은 디자인 점착성과 환경 점착성으로 나눌 수 있다.\n\n    시스템에 코드를 추가하는 것보다 핵을 추가하는 것이 더 쉽다면 디자인 점착성이 높다고 할 수 있다. 예를 들어 수정이 필요할 때 다양한 방법으로 수정할 수 있을 것이다. 어떤 것은 디자인을 유지하는 것이고 어떤 것은 그렇지 못할 것이다(핵을 추가).\n\n    환경 점착성은 개발환경이 느리고 효율적이지 못할 때 나타난다. 예를들면 컴파일 시간이 매우 길다면 큰 규모의 수정이 필요하더라도 개발자는 recompile 시간이 길기 때문에 작은 규모의 수정으로 문제를 해결할려고 할 것이다.\n\n위의 design smell은 곧 나쁜 디자인을 의미한다.(스파게티 코드)\n\n# Robert C. Martin\'s Software design principles(SOLID)\nRobejt C. Martin은 5가지 Software design principles을 정의하였고 앞글자를 따서 SOLID라고 부른다.\n\n## Single Responsibility Principle(SRP)\nA class should have one, and only one, reason to change  \n\n클래스는 오직 하나의 이유로 수정이 되어야 한다는 것을 의미한다.\n\n### Example\n\nSRP를 위반하는 예제로 아래 클래스 다이어그램을 보자\n\n![](https://images.velog.io/images/whow1101/post/57693bec-b90d-47aa-a2dc-a4916b663234/overview_pattern_1.PNG)\n\nRegister 클래스가 Student 클래스에 dependency를 가지고 있는 모습이다.\n만약 여기서 어떤 클래스가 Student를 다양한 방법으로 정렬을 하고 싶다면 아래와 같이 구현 할 수 있다.\n\n![](https://images.velog.io/images/whow1101/post/c7db57cb-5579-45eb-b999-ffc2f57b2061/overview_pattern_2.PNG)\n\n하지만 Register 클래스는 어떠한 변경도 일어나야하지 않지만 Student 클래스가 바뀌어서 Register 클래스가 영향을 받는다. 정렬을 위한 변경이 관련없는 Reigster 클래스에 영향을 끼쳤기 때문에 SRP를 위반한다.\n\n![](https://images.velog.io/images/whow1101/post/ddd405f3-ad24-40ac-bf58-b7d9629006f8/overview_pattern_3.PNG)\n\n위의 그림은 SRP 위반을 해결하기 위한 클래스 다이어그램이다. 각각의 정렬 방식을 가진 클래스를 새로 생성하고 Client는 새로 생긴 클래스를 호출한다.\n\n### 관련 측정 항목\nSRP는 같은 목적으로 responsibility를 가지는 cohesion과 관련이 깊다. \n\n## Open Closed Principle(OCP)\nSoftware entities (classes, modules, functions, etc) should be open for extension but closed for modification\n\n자신의 확장에는 열려있고 주변의 변화에는 닫혀 있어야 하는 것을 의미한다.\n\n### Example\n\n![](https://images.velog.io/images/whow1101/post/567b0348-8bad-40a4-baf7-065baf6330a7/overview_pattern_4.PNG)\n```java\nvoid incAll(Employee[] emps) {\n    for (int i=0; i<emps.size(); i++) {\n        if(emps[i].empType == FACULTY)\n            incFacultySalary((FACULTY)emps[i])\n        else if(emps[i].empType == STAFF)\n            incStaffSalary((STAFF)emps[i])\n        else if(emps[i].empType == SECRETARY)\n            incSecretarySalary((SECRETARY)emps[i])\n    }\n}\n```\n위의 예제는 아래 문제점을 가지고 있다.\n\nRigid - 새로운 employee type이 계속 요구된다.\n\nFragile - 많은 if/lese 구문과 코드를 찾기 어렵다\n\n![](https://images.velog.io/images/whow1101/post/ed143d4d-c85b-4c7a-82c9-ddd3cb0974cc/overview_pattern_5.PNG)\n\n이전에 설명한 문제점을 해결한 클래스 다이어그램이다.\n\nincAll() 함수를 통해서 문제를 해결한 것을 볼 수 있다.\n\n## Liskov Substitution Principle(LSP)\nsubtypes must be substitutable for their base types\n\nbase 클래스에서 파생된 클래스는 base 클래스를 대체해서 사용할 수 있어야한다.\n\n### Example\n아래는 Java 라이브러리의 Date 클래스이다.\n\n![](https://images.velog.io/images/whow1101/post/c85dc1d3-c49f-4882-8b34-d11737e0b4c1/overview_pattern_6.PNG)\n```java\njava.util.Date date = new java.util.Date();\nint dateValue = date.getDate(); // Okay\n\ndate = new java.sql.Time(10,10,10);\ndataValue = date.getDate(); // throws IllegalArgumentException\n```\n\n### Inheritance Vs. Composition\n\n![](https://images.velog.io/images/whow1101/post/e3fcc38c-4cd1-4bcf-b0f9-108787d30a1b/overview_pattern_7.PNG)\n\n위의 예제엇 만약 List의 Implemenation을 재사용하게 된다면 inheritance보다 object composition을 사용하는 것을 추천한다.\n\n위에서 Queue 클래스가 List 클래스를 inheritance 한다면 LSP를 위반하게 된다.\n\n## Interface Segregation Principle(ISP)\nClients should not be forced to depend on methods they do not use\n\n사용하지 않는 메소드에 의존하면 안된다.\n\n![](https://images.velog.io/images/whow1101/post/78f2622b-b05b-4e3f-a810-f7519b97371d/overview_pattern_8.PNG)\n\nRoast Application은 getName(), getSSN() 메소드만을 사용하고 Account Application은 getInvoice(), postPayment() 메소드만을 사용한다.\n\n![](https://images.velog.io/images/whow1101/post/a1411b66-caed-4190-8e54-474d7155fd51/overview_pattern_9.PNG)\n위 클래스 다이어그램 처럼 클래스에 맞는 interface를 만들어서 제공하면 ISP 문제를 해결할 수 있다.\n\n## Dependency Inversion Principle(DIP)\nhigh-level modules should not depend on low-level modules. Both should depend on abstractions\n\n자신(high level module)보다 변하기 쉬운 모듈(low level modeul)에 의존해서는 안된다.\n\n### Inversion?\n\n![](https://images.velog.io/images/whow1101/post/eb1bd2bf-b8ad-4309-9d3c-746eceb28034/overview_pattern_10.PNG)\n\nProgram 클래스는 Module 클래스에 dependency를 가지고 있으며 Module 클래스는 Function 클래스에 의존하고 있다.\n\n![](https://images.velog.io/images/whow1101/post/828c9238-78a2-4b1d-aefc-5d4e604af345/overview_pattern_11.PNG)\n\nModule 클래스를 인터페이스 클래스로 변경을 한 클래스 다이어그램이다.\n이전 그림과 다르게 depenedency가 inversion 된 모습을 볼 수 있다.\n\n\nDIP는 dependency를 inversion 하는 것 뿐 아니라 ownership 또한 inversion 한다.', '2022-06-07', '76');

